// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

// Discount applications capture the intentions of a discount source at
// the time of application.
type DiscountApplication interface {
	IsDiscountApplication()
}

// Represents an error in the input of a mutation.
type DisplayableError interface {
	IsDisplayableError()
}

// Represents information about the metafields associated to the specified resource.
type HasMetafields interface {
	IsHasMetafields()
}

// A resource that the metafield belongs to.
type MetafieldParentResource interface {
	IsMetafieldParentResource()
}

// An object with an ID to support global identification.
type Node interface {
	IsNode()
}

// The price value (fixed or percentage) for a discount application.
type PricingValue interface {
	IsPricingValue()
}

// A version of the API.
type APIVersion struct {
	// The human-readable name of the version.
	DisplayName string `json:"displayName"`
	// The unique identifier of an ApiVersion. All supported API versions have a date-based (YYYY-MM) or `unstable` handle.
	Handle string `json:"handle"`
	// Whether the version is supported by Shopify.
	Supported bool `json:"supported"`
}

// Details about the gift card used on the checkout.
type AppliedGiftCard struct {
	// The amount that was taken from the gift card by applying it.
	AmountUsed string `json:"amountUsed"`
	// The amount that was taken from the gift card by applying it.
	AmountUsedV2 *MoneyV2 `json:"amountUsedV2"`
	// The amount left on the gift card.
	Balance string `json:"balance"`
	// The amount left on the gift card.
	BalanceV2 *MoneyV2 `json:"balanceV2"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The last characters of the gift card.
	LastCharacters string `json:"lastCharacters"`
	// The amount that was applied to the checkout in its currency.
	PresentmentAmountUsed *MoneyV2 `json:"presentmentAmountUsed"`
}

func (AppliedGiftCard) IsNode() {}

// An article in an online store blog.
type Article struct {
	// The article's author.
	Author *ArticleAuthor `json:"author"`
	// The article's author.
	AuthorV2 *ArticleAuthor `json:"authorV2"`
	// The blog that the article belongs to.
	Blog *Blog `json:"blog"`
	// List of comments posted on the article.
	Comments *CommentConnection `json:"comments"`
	// Stripped content of the article, single line with HTML tags removed.
	Content string `json:"content"`
	// The content of the article, complete with HTML formatting.
	ContentHTML string `json:"contentHtml"`
	// Stripped excerpt of the article, single line with HTML tags removed.
	Excerpt *string `json:"excerpt"`
	// The excerpt of the article, complete with HTML formatting.
	ExcerptHTML *string `json:"excerptHtml"`
	// A human-friendly unique string for the Article automatically generated from its title.
	Handle string `json:"handle"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The image associated with the article.
	Image *Image `json:"image"`
	// The date and time when the article was published.
	PublishedAt string `json:"publishedAt"`
	// The article’s SEO information.
	Seo *Seo `json:"seo"`
	// A categorization that a article can be tagged with.
	Tags []string `json:"tags"`
	// The article’s name.
	Title string `json:"title"`
	// The url pointing to the article accessible from the web.
	URL string `json:"url"`
}

func (Article) IsNode() {}

// The author of an article.
type ArticleAuthor struct {
	// The author's bio.
	Bio *string `json:"bio"`
	// The author’s email.
	Email string `json:"email"`
	// The author's first name.
	FirstName string `json:"firstName"`
	// The author's last name.
	LastName string `json:"lastName"`
	// The author's full name.
	Name string `json:"name"`
}

// An auto-generated type for paginating through multiple Articles.
type ArticleConnection struct {
	// A list of edges.
	Edges []*ArticleEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one Article and a cursor during pagination.
type ArticleEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ArticleEdge.
	Node *Article `json:"node"`
}

// Represents a generic custom attribute.
type Attribute struct {
	// Key or name of the attribute.
	Key string `json:"key"`
	// Value of the attribute.
	Value *string `json:"value"`
}

// Specifies the input fields required for an attribute.
type AttributeInput struct {
	// Key or name of the attribute.
	Key string `json:"key"`
	// Value of the attribute.
	Value string `json:"value"`
}

// Automatic discount applications capture the intentions of a discount that was automatically applied.
type AutomaticDiscountApplication struct {
	// The method by which the discount's value is allocated to its entitled items.
	AllocationMethod DiscountApplicationAllocationMethod `json:"allocationMethod"`
	// Which lines of targetType that the discount is allocated over.
	TargetSelection DiscountApplicationTargetSelection `json:"targetSelection"`
	// The type of line that the discount is applicable towards.
	TargetType DiscountApplicationTargetType `json:"targetType"`
	// The title of the application.
	Title string `json:"title"`
	// The value of the discount application.
	Value PricingValue `json:"value"`
}

func (AutomaticDiscountApplication) IsDiscountApplication() {}

// A collection of available shipping rates for a checkout.
type AvailableShippingRates struct {
	// Whether or not the shipping rates are ready.
	// The `shippingRates` field is `null` when this value is `false`.
	// This field should be polled until its value becomes `true`.
	Ready bool `json:"ready"`
	// The fetched shipping rates. `null` until the `ready` field is `true`.
	ShippingRates []*ShippingRate `json:"shippingRates"`
}

// An online store blog.
type Blog struct {
	// Find an article by its handle.
	ArticleByHandle *Article `json:"articleByHandle"`
	// List of the blog's articles.
	Articles *ArticleConnection `json:"articles"`
	// The authors who have contributed to the blog.
	Authors []*ArticleAuthor `json:"authors"`
	// A human-friendly unique string for the Blog automatically generated from its title.
	Handle string `json:"handle"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The blogs’s title.
	Title string `json:"title"`
	// The url pointing to the blog accessible from the web.
	URL string `json:"url"`
}

func (Blog) IsNode() {}

// An auto-generated type for paginating through multiple Blogs.
type BlogConnection struct {
	// A list of edges.
	Edges []*BlogEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one Blog and a cursor during pagination.
type BlogEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of BlogEdge.
	Node *Blog `json:"node"`
}

// A container for all the information required to checkout items and pay.
type Checkout struct {
	// The gift cards used on the checkout.
	AppliedGiftCards []*AppliedGiftCard `json:"appliedGiftCards"`
	// The available shipping rates for this Checkout.
	// Should only be used when checkout `requiresShipping` is `true` and
	// the shipping address is valid.
	AvailableShippingRates *AvailableShippingRates `json:"availableShippingRates"`
	// The date and time when the checkout was completed.
	CompletedAt *string `json:"completedAt"`
	// The date and time when the checkout was created.
	CreatedAt string `json:"createdAt"`
	// The currency code for the Checkout.
	CurrencyCode CurrencyCode `json:"currencyCode"`
	// A list of extra information that is added to the checkout.
	CustomAttributes []*Attribute `json:"customAttributes"`
	// The customer associated with the checkout.
	Customer *Customer `json:"customer"`
	// Discounts that have been applied on the checkout.
	DiscountApplications *DiscountApplicationConnection `json:"discountApplications"`
	// The email attached to this checkout.
	Email *string `json:"email"`
	// Globally unique identifier.
	ID string `json:"id"`
	// A list of line item objects, each one containing information about an item in the checkout.
	LineItems *CheckoutLineItemConnection `json:"lineItems"`
	// The sum of all the prices of all the items in the checkout. Duties, taxes, shipping and discounts excluded.
	LineItemsSubtotalPrice *MoneyV2 `json:"lineItemsSubtotalPrice"`
	// The note associated with the checkout.
	Note *string `json:"note"`
	// The resulting order from a paid checkout.
	Order *Order `json:"order"`
	// The Order Status Page for this Checkout, null when checkout is not completed.
	OrderStatusURL *string `json:"orderStatusUrl"`
	// The amount left to be paid. This is equal to the cost of the line items, taxes and shipping minus discounts and gift cards.
	PaymentDue string `json:"paymentDue"`
	// The amount left to be paid. This is equal to the cost of the line items, duties, taxes and shipping minus discounts and gift cards.
	PaymentDueV2 *MoneyV2 `json:"paymentDueV2"`
	// Whether or not the Checkout is ready and can be completed. Checkouts may
	// have asynchronous operations that can take time to finish. If you want
	// to complete a checkout or ensure all the fields are populated and up to
	// date, polling is required until the value is true.
	Ready bool `json:"ready"`
	// States whether or not the fulfillment requires shipping.
	RequiresShipping bool `json:"requiresShipping"`
	// The shipping address to where the line items will be shipped.
	ShippingAddress *MailingAddress `json:"shippingAddress"`
	// The discounts that have been allocated onto the shipping line by discount applications.
	ShippingDiscountAllocations []*DiscountAllocation `json:"shippingDiscountAllocations"`
	// Once a shipping rate is selected by the customer it is transitioned to a `shipping_line` object.
	ShippingLine *ShippingRate `json:"shippingLine"`
	// Price of the checkout before shipping and taxes.
	SubtotalPrice string `json:"subtotalPrice"`
	// Price of the checkout before duties, shipping and taxes.
	SubtotalPriceV2 *MoneyV2 `json:"subtotalPriceV2"`
	// Specifies if the Checkout is tax exempt.
	TaxExempt bool `json:"taxExempt"`
	// Specifies if taxes are included in the line item and shipping line prices.
	TaxesIncluded bool `json:"taxesIncluded"`
	// The sum of all the prices of all the items in the checkout, taxes and discounts included.
	TotalPrice string `json:"totalPrice"`
	// The sum of all the prices of all the items in the checkout, duties, taxes and discounts included.
	TotalPriceV2 *MoneyV2 `json:"totalPriceV2"`
	// The sum of all the taxes applied to the line items and shipping lines in the checkout.
	TotalTax string `json:"totalTax"`
	// The sum of all the taxes applied to the line items and shipping lines in the checkout.
	TotalTaxV2 *MoneyV2 `json:"totalTaxV2"`
	// The date and time when the checkout was last updated.
	UpdatedAt string `json:"updatedAt"`
	// The url pointing to the checkout accessible from the web.
	WebURL string `json:"webUrl"`
}

func (Checkout) IsNode() {}

// Specifies the fields required to update a checkout's attributes.
type CheckoutAttributesUpdateInput struct {
	// The text of an optional note that a shop owner can attach to the checkout.
	Note *string `json:"note"`
	// A list of extra information that is added to the checkout.
	CustomAttributes []*AttributeInput `json:"customAttributes"`
	// Allows setting partial addresses on a Checkout, skipping the full validation of attributes.
	// The required attributes are city, province, and country.
	// Full validation of the addresses is still done at complete time.
	AllowPartialAddresses *bool `json:"allowPartialAddresses"`
}

// Return type for `checkoutAttributesUpdate` mutation.
type CheckoutAttributesUpdatePayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies the fields required to update a checkout's attributes.
type CheckoutAttributesUpdateV2Input struct {
	// The text of an optional note that a shop owner can attach to the checkout.
	Note *string `json:"note"`
	// A list of extra information that is added to the checkout.
	CustomAttributes []*AttributeInput `json:"customAttributes"`
	// Allows setting partial addresses on a Checkout, skipping the full validation of attributes.
	// The required attributes are city, province, and country.
	// Full validation of the addresses is still done at complete time.
	AllowPartialAddresses *bool `json:"allowPartialAddresses"`
}

// Return type for `checkoutAttributesUpdateV2` mutation.
type CheckoutAttributesUpdateV2Payload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutCompleteFree` mutation.
type CheckoutCompleteFreePayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutCompleteWithCreditCard` mutation.
type CheckoutCompleteWithCreditCardPayload struct {
	// The checkout on which the payment was applied.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// A representation of the attempted payment.
	Payment *Payment `json:"payment"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutCompleteWithCreditCardV2` mutation.
type CheckoutCompleteWithCreditCardV2Payload struct {
	// The checkout on which the payment was applied.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// A representation of the attempted payment.
	Payment *Payment `json:"payment"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutCompleteWithTokenizedPayment` mutation.
type CheckoutCompleteWithTokenizedPaymentPayload struct {
	// The checkout on which the payment was applied.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// A representation of the attempted payment.
	Payment *Payment `json:"payment"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutCompleteWithTokenizedPaymentV2` mutation.
type CheckoutCompleteWithTokenizedPaymentV2Payload struct {
	// The checkout on which the payment was applied.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// A representation of the attempted payment.
	Payment *Payment `json:"payment"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies the fields required to create a checkout.
type CheckoutCreateInput struct {
	// The email with which the customer wants to checkout.
	Email *string `json:"email"`
	// A list of line item objects, each one containing information about an item in the checkout.
	LineItems []*CheckoutLineItemInput `json:"lineItems"`
	// The shipping address to where the line items will be shipped.
	ShippingAddress *MailingAddressInput `json:"shippingAddress"`
	// The text of an optional note that a shop owner can attach to the checkout.
	Note *string `json:"note"`
	// A list of extra information that is added to the checkout.
	CustomAttributes []*AttributeInput `json:"customAttributes"`
	// Allows setting partial addresses on a Checkout, skipping the full validation of attributes.
	// The required attributes are city, province, and country.
	// Full validation of addresses is still done at complete time.
	AllowPartialAddresses *bool `json:"allowPartialAddresses"`
	// The three-letter currency code of one of the shop's enabled presentment currencies.
	// Including this field creates a checkout in the specified currency. By default, new
	// checkouts are created in the shop's primary currency.
	PresentmentCurrencyCode *CurrencyCode `json:"presentmentCurrencyCode"`
}

// Return type for `checkoutCreate` mutation.
type CheckoutCreatePayload struct {
	// The new checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutCustomerAssociate` mutation.
type CheckoutCustomerAssociatePayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// The associated customer object.
	Customer *Customer `json:"customer"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutCustomerAssociateV2` mutation.
type CheckoutCustomerAssociateV2Payload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// The associated customer object.
	Customer *Customer `json:"customer"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutCustomerDisassociate` mutation.
type CheckoutCustomerDisassociatePayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutCustomerDisassociateV2` mutation.
type CheckoutCustomerDisassociateV2Payload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutDiscountCodeApply` mutation.
type CheckoutDiscountCodeApplyPayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutDiscountCodeApplyV2` mutation.
type CheckoutDiscountCodeApplyV2Payload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutDiscountCodeRemove` mutation.
type CheckoutDiscountCodeRemovePayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutEmailUpdate` mutation.
type CheckoutEmailUpdatePayload struct {
	// The checkout object with the updated email.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutEmailUpdateV2` mutation.
type CheckoutEmailUpdateV2Payload struct {
	// The checkout object with the updated email.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutGiftCardApply` mutation.
type CheckoutGiftCardApplyPayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutGiftCardRemove` mutation.
type CheckoutGiftCardRemovePayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutGiftCardRemoveV2` mutation.
type CheckoutGiftCardRemoveV2Payload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutGiftCardsAppend` mutation.
type CheckoutGiftCardsAppendPayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// A single line item in the checkout, grouped by variant and attributes.
type CheckoutLineItem struct {
	// Extra information in the form of an array of Key-Value pairs about the line item.
	CustomAttributes []*Attribute `json:"customAttributes"`
	// The discounts that have been allocated onto the checkout line item by discount applications.
	DiscountAllocations []*DiscountAllocation `json:"discountAllocations"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The quantity of the line item.
	Quantity int `json:"quantity"`
	// Title of the line item. Defaults to the product's title.
	Title string `json:"title"`
	// Product variant of the line item.
	Variant *ProductVariant `json:"variant"`
}

func (CheckoutLineItem) IsNode() {}

// An auto-generated type for paginating through multiple CheckoutLineItems.
type CheckoutLineItemConnection struct {
	// A list of edges.
	Edges []*CheckoutLineItemEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one CheckoutLineItem and a cursor during pagination.
type CheckoutLineItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of CheckoutLineItemEdge.
	Node *CheckoutLineItem `json:"node"`
}

// Specifies the input fields to create a line item on a checkout.
type CheckoutLineItemInput struct {
	// Extra information in the form of an array of Key-Value pairs about the line item.
	CustomAttributes []*AttributeInput `json:"customAttributes"`
	// The quantity of the line item.
	Quantity int `json:"quantity"`
	// The identifier of the product variant for the line item.
	VariantID string `json:"variantId"`
}

// Specifies the input fields to update a line item on the checkout.
type CheckoutLineItemUpdateInput struct {
	// The identifier of the line item.
	ID *string `json:"id"`
	// The variant identifier of the line item.
	VariantID *string `json:"variantId"`
	// The quantity of the line item.
	Quantity *int `json:"quantity"`
	// Extra information in the form of an array of Key-Value pairs about the line item.
	CustomAttributes []*AttributeInput `json:"customAttributes"`
}

// Return type for `checkoutLineItemsAdd` mutation.
type CheckoutLineItemsAddPayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutLineItemsRemove` mutation.
type CheckoutLineItemsRemovePayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutLineItemsReplace` mutation.
type CheckoutLineItemsReplacePayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	UserErrors []*CheckoutUserError `json:"userErrors"`
}

// Return type for `checkoutLineItemsUpdate` mutation.
type CheckoutLineItemsUpdatePayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutShippingAddressUpdate` mutation.
type CheckoutShippingAddressUpdatePayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutShippingAddressUpdateV2` mutation.
type CheckoutShippingAddressUpdateV2Payload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutShippingLineUpdate` mutation.
type CheckoutShippingLineUpdatePayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout"`
	// List of errors that occurred executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Represents an error that happens during execution of a checkout mutation.
type CheckoutUserError struct {
	// Error code to uniquely identify the error.
	Code *CheckoutErrorCode `json:"code"`
	// Path to the input field which caused the error.
	Field []string `json:"field"`
	// The error message.
	Message string `json:"message"`
}

func (CheckoutUserError) IsDisplayableError() {}

// A collection represents a grouping of products that a shop owner can create to organize them or make their shops easier to browse.
type Collection struct {
	// Stripped description of the collection, single line with HTML tags removed.
	Description string `json:"description"`
	// The description of the collection, complete with HTML formatting.
	DescriptionHTML string `json:"descriptionHtml"`
	// A human-friendly unique string for the collection automatically generated from its title.
	// Limit of 255 characters.
	Handle string `json:"handle"`
	// Globally unique identifier.
	ID string `json:"id"`
	// Image associated with the collection.
	Image *Image `json:"image"`
	// List of products in the collection.
	Products *ProductConnection `json:"products"`
	// The collection’s name. Limit of 255 characters.
	Title string `json:"title"`
	// The date and time when the collection was last modified.
	UpdatedAt string `json:"updatedAt"`
}

func (Collection) IsNode() {}

// An auto-generated type for paginating through multiple Collections.
type CollectionConnection struct {
	// A list of edges.
	Edges []*CollectionEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one Collection and a cursor during pagination.
type CollectionEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of CollectionEdge.
	Node *Collection `json:"node"`
}

// A comment on an article.
type Comment struct {
	// The comment’s author.
	Author *CommentAuthor `json:"author"`
	// Stripped content of the comment, single line with HTML tags removed.
	Content string `json:"content"`
	// The content of the comment, complete with HTML formatting.
	ContentHTML string `json:"contentHtml"`
	// Globally unique identifier.
	ID string `json:"id"`
}

func (Comment) IsNode() {}

// The author of a comment.
type CommentAuthor struct {
	// The author's email.
	Email string `json:"email"`
	// The author’s name.
	Name string `json:"name"`
}

// An auto-generated type for paginating through multiple Comments.
type CommentConnection struct {
	// A list of edges.
	Edges []*CommentEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one Comment and a cursor during pagination.
type CommentEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of CommentEdge.
	Node *Comment `json:"node"`
}

// Credit card information used for a payment.
type CreditCard struct {
	// The brand of the credit card.
	Brand *string `json:"brand"`
	// The expiry month of the credit card.
	ExpiryMonth *int `json:"expiryMonth"`
	// The expiry year of the credit card.
	ExpiryYear *int `json:"expiryYear"`
	// The credit card's BIN number.
	FirstDigits *string `json:"firstDigits"`
	// The first name of the card holder.
	FirstName *string `json:"firstName"`
	// The last 4 digits of the credit card.
	LastDigits *string `json:"lastDigits"`
	// The last name of the card holder.
	LastName *string `json:"lastName"`
	// The masked credit card number with only the last 4 digits displayed.
	MaskedNumber *string `json:"maskedNumber"`
}

// Specifies the fields required to complete a checkout with
// a Shopify vaulted credit card payment.
type CreditCardPaymentInput struct {
	// The amount of the payment.
	Amount string `json:"amount"`
	// A unique client generated key used to avoid duplicate charges. When a duplicate payment is found, the original is returned instead of creating a new one.
	IdempotencyKey string `json:"idempotencyKey"`
	// The billing address for the payment.
	BillingAddress *MailingAddressInput `json:"billingAddress"`
	// The ID returned by Shopify's Card Vault.
	VaultID string `json:"vaultId"`
	// Executes the payment in test mode if possible. Defaults to `false`.
	Test *bool `json:"test"`
}

// Specifies the fields required to complete a checkout with
// a Shopify vaulted credit card payment.
type CreditCardPaymentInputV2 struct {
	// The amount and currency of the payment.
	PaymentAmount *MoneyInput `json:"paymentAmount"`
	// A unique client generated key used to avoid duplicate charges. When a duplicate payment is found, the original is returned instead of creating a new one.
	IdempotencyKey string `json:"idempotencyKey"`
	// The billing address for the payment.
	BillingAddress *MailingAddressInput `json:"billingAddress"`
	// The ID returned by Shopify's Card Vault.
	VaultID string `json:"vaultId"`
	// Executes the payment in test mode if possible. Defaults to `false`.
	Test *bool `json:"test"`
}

// A customer represents a customer account with the shop. Customer accounts store contact information for the customer, saving logged-in customers the trouble of having to provide it at every checkout.
type Customer struct {
	// Indicates whether the customer has consented to be sent marketing material via email.
	AcceptsMarketing bool `json:"acceptsMarketing"`
	// A list of addresses for the customer.
	Addresses *MailingAddressConnection `json:"addresses"`
	// The date and time when the customer was created.
	CreatedAt string `json:"createdAt"`
	// The customer’s default address.
	DefaultAddress *MailingAddress `json:"defaultAddress"`
	// The customer’s name, email or phone number.
	DisplayName string `json:"displayName"`
	// The customer’s email address.
	Email *string `json:"email"`
	// The customer’s first name.
	FirstName *string `json:"firstName"`
	// A unique identifier for the customer.
	ID string `json:"id"`
	// The customer's most recently updated, incomplete checkout.
	LastIncompleteCheckout *Checkout `json:"lastIncompleteCheckout"`
	// The customer’s last name.
	LastName *string `json:"lastName"`
	// The orders associated with the customer.
	Orders *OrderConnection `json:"orders"`
	// The customer’s phone number.
	Phone *string `json:"phone"`
	// A comma separated list of tags that have been added to the customer.
	// Additional access scope required: unauthenticated_read_customer_tags.
	Tags []string `json:"tags"`
	// The date and time when the customer information was updated.
	UpdatedAt string `json:"updatedAt"`
}

// A CustomerAccessToken represents the unique token required to make modifications to the customer object.
type CustomerAccessToken struct {
	// The customer’s access token.
	AccessToken string `json:"accessToken"`
	// The date and time when the customer access token expires.
	ExpiresAt string `json:"expiresAt"`
}

// Specifies the input fields required to create a customer access token.
type CustomerAccessTokenCreateInput struct {
	// The email associated to the customer.
	Email string `json:"email"`
	// The login password to be used by the customer.
	Password string `json:"password"`
}

// Return type for `customerAccessTokenCreate` mutation.
type CustomerAccessTokenCreatePayload struct {
	// The newly created customer access token object.
	CustomerAccessToken *CustomerAccessToken `json:"customerAccessToken"`
	// List of errors that occurred executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerAccessTokenDelete` mutation.
type CustomerAccessTokenDeletePayload struct {
	// The destroyed access token.
	DeletedAccessToken *string `json:"deletedAccessToken"`
	// ID of the destroyed customer access token.
	DeletedCustomerAccessTokenID *string `json:"deletedCustomerAccessTokenId"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerAccessTokenRenew` mutation.
type CustomerAccessTokenRenewPayload struct {
	// The renewed customer access token object.
	CustomerAccessToken *CustomerAccessToken `json:"customerAccessToken"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies the input fields required to activate a customer.
type CustomerActivateInput struct {
	// The activation token required to activate the customer.
	ActivationToken string `json:"activationToken"`
	// New password that will be set during activation.
	Password string `json:"password"`
}

// Return type for `customerActivate` mutation.
type CustomerActivatePayload struct {
	// The customer object.
	Customer *Customer `json:"customer"`
	// A newly created customer access token object for the customer.
	CustomerAccessToken *CustomerAccessToken `json:"customerAccessToken"`
	// List of errors that occurred executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerAddressCreate` mutation.
type CustomerAddressCreatePayload struct {
	// The new customer address object.
	CustomerAddress *MailingAddress `json:"customerAddress"`
	// List of errors that occurred executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerAddressDelete` mutation.
type CustomerAddressDeletePayload struct {
	// List of errors that occurred executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// ID of the deleted customer address.
	DeletedCustomerAddressID *string `json:"deletedCustomerAddressId"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerAddressUpdate` mutation.
type CustomerAddressUpdatePayload struct {
	// The customer’s updated mailing address.
	CustomerAddress *MailingAddress `json:"customerAddress"`
	// List of errors that occurred executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies the fields required to create a new customer.
type CustomerCreateInput struct {
	// The customer’s first name.
	FirstName *string `json:"firstName"`
	// The customer’s last name.
	LastName *string `json:"lastName"`
	// The customer’s email.
	Email string `json:"email"`
	// A unique phone number for the customer.
	//
	// Formatted using E.164 standard. For example, _+16135551111_.
	Phone *string `json:"phone"`
	// The login password used by the customer.
	Password string `json:"password"`
	// Indicates whether the customer has consented to be sent marketing material via email.
	AcceptsMarketing *bool `json:"acceptsMarketing"`
}

// Return type for `customerCreate` mutation.
type CustomerCreatePayload struct {
	// The created customer object.
	Customer *Customer `json:"customer"`
	// List of errors that occurred executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerDefaultAddressUpdate` mutation.
type CustomerDefaultAddressUpdatePayload struct {
	// The updated customer object.
	Customer *Customer `json:"customer"`
	// List of errors that occurred executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerRecover` mutation.
type CustomerRecoverPayload struct {
	// List of errors that occurred executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerResetByUrl` mutation.
type CustomerResetByURLPayload struct {
	// The customer object which was reset.
	Customer *Customer `json:"customer"`
	// A newly created customer access token object for the customer.
	CustomerAccessToken *CustomerAccessToken `json:"customerAccessToken"`
	// List of errors that occurred executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies the fields required to reset a customer’s password.
type CustomerResetInput struct {
	// The reset token required to reset the customer’s password.
	ResetToken string `json:"resetToken"`
	// New password that will be set as part of the reset password process.
	Password string `json:"password"`
}

// Return type for `customerReset` mutation.
type CustomerResetPayload struct {
	// The customer object which was reset.
	Customer *Customer `json:"customer"`
	// A newly created customer access token object for the customer.
	CustomerAccessToken *CustomerAccessToken `json:"customerAccessToken"`
	// List of errors that occurred executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies the fields required to update the Customer information.
type CustomerUpdateInput struct {
	// The customer’s first name.
	FirstName *string `json:"firstName"`
	// The customer’s last name.
	LastName *string `json:"lastName"`
	// The customer’s email.
	Email *string `json:"email"`
	// A unique phone number for the customer.
	//
	// Formatted using E.164 standard. For example, _+16135551111_. To remove the phone number, specify `null`.
	Phone *string `json:"phone"`
	// The login password used by the customer.
	Password *string `json:"password"`
	// Indicates whether the customer has consented to be sent marketing material via email.
	AcceptsMarketing *bool `json:"acceptsMarketing"`
}

// Return type for `customerUpdate` mutation.
type CustomerUpdatePayload struct {
	// The updated customer object.
	Customer *Customer `json:"customer"`
	// The newly created customer access token. If the customer's password is updated, all previous access tokens
	// (including the one used to perform this mutation) become invalid, and a new token is generated.
	CustomerAccessToken *CustomerAccessToken `json:"customerAccessToken"`
	// List of errors that occurred executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Represents an error that happens during execution of a customer mutation.
type CustomerUserError struct {
	// Error code to uniquely identify the error.
	Code *CustomerErrorCode `json:"code"`
	// Path to the input field which caused the error.
	Field []string `json:"field"`
	// The error message.
	Message string `json:"message"`
}

func (CustomerUserError) IsDisplayableError() {}

// An amount discounting the line that has been allocated by a discount.
type DiscountAllocation struct {
	// Amount of discount allocated.
	AllocatedAmount *MoneyV2 `json:"allocatedAmount"`
	// The discount this allocated amount originated from.
	DiscountApplication DiscountApplication `json:"discountApplication"`
}

// An auto-generated type for paginating through multiple DiscountApplications.
type DiscountApplicationConnection struct {
	// A list of edges.
	Edges []*DiscountApplicationEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one DiscountApplication and a cursor during pagination.
type DiscountApplicationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of DiscountApplicationEdge.
	Node DiscountApplication `json:"node"`
}

// Discount code applications capture the intentions of a discount code at
// the time that it is applied.
type DiscountCodeApplication struct {
	// The method by which the discount's value is allocated to its entitled items.
	AllocationMethod DiscountApplicationAllocationMethod `json:"allocationMethod"`
	// Specifies whether the discount code was applied successfully.
	Applicable bool `json:"applicable"`
	// The string identifying the discount code that was used at the time of application.
	Code string `json:"code"`
	// Which lines of targetType that the discount is allocated over.
	TargetSelection DiscountApplicationTargetSelection `json:"targetSelection"`
	// The type of line that the discount is applicable towards.
	TargetType DiscountApplicationTargetType `json:"targetType"`
	// The value of the discount application.
	Value PricingValue `json:"value"`
}

func (DiscountCodeApplication) IsDiscountApplication() {}

// Represents a web address.
type Domain struct {
	// The host name of the domain (eg: `example.com`).
	Host string `json:"host"`
	// Whether SSL is enabled or not.
	SslEnabled bool `json:"sslEnabled"`
	// The URL of the domain (eg: `https://example.com`).
	URL string `json:"url"`
}

// Represents a single fulfillment in an order.
type Fulfillment struct {
	// List of the fulfillment's line items.
	FulfillmentLineItems *FulfillmentLineItemConnection `json:"fulfillmentLineItems"`
	// The name of the tracking company.
	TrackingCompany *string `json:"trackingCompany"`
	// Tracking information associated with the fulfillment,
	// such as the tracking number and tracking URL.
	TrackingInfo []*FulfillmentTrackingInfo `json:"trackingInfo"`
}

// Represents a single line item in a fulfillment. There is at most one fulfillment line item for each order line item.
type FulfillmentLineItem struct {
	// The associated order's line item.
	LineItem *OrderLineItem `json:"lineItem"`
	// The amount fulfilled in this fulfillment.
	Quantity int `json:"quantity"`
}

// An auto-generated type for paginating through multiple FulfillmentLineItems.
type FulfillmentLineItemConnection struct {
	// A list of edges.
	Edges []*FulfillmentLineItemEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one FulfillmentLineItem and a cursor during pagination.
type FulfillmentLineItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of FulfillmentLineItemEdge.
	Node *FulfillmentLineItem `json:"node"`
}

// Tracking information associated with the fulfillment.
type FulfillmentTrackingInfo struct {
	// The tracking number of the fulfillment.
	Number *string `json:"number"`
	// The URL to track the fulfillment.
	URL *string `json:"url"`
}

// Represents an image resource.
type Image struct {
	// A word or phrase to share the nature or contents of an image.
	AltText *string `json:"altText"`
	// A unique identifier for the image.
	ID *string `json:"id"`
	// The location of the original image as a URL.
	//
	// If there are any existing transformations in the original source URL, they will remain and not be stripped.
	OriginalSrc string `json:"originalSrc"`
	// The location of the image as a URL.
	Src string `json:"src"`
	// The location of the transformed image as a URL.
	//
	// All transformation arguments are considered "best-effort". If they can be applied to an image, they will be.
	// Otherwise any transformations which an image type does not support will be ignored.
	TransformedSrc string `json:"transformedSrc"`
}

// An auto-generated type for paginating through multiple Images.
type ImageConnection struct {
	// A list of edges.
	Edges []*ImageEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one Image and a cursor during pagination.
type ImageEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ImageEdge.
	Node *Image `json:"node"`
}

// Represents a mailing address for customers and shipping.
type MailingAddress struct {
	// The first line of the address. Typically the street address or PO Box number.
	Address1 *string `json:"address1"`
	// The second line of the address. Typically the number of the apartment, suite, or unit.
	Address2 *string `json:"address2"`
	// The name of the city, district, village, or town.
	City *string `json:"city"`
	// The name of the customer's company or organization.
	Company *string `json:"company"`
	// The name of the country.
	Country *string `json:"country"`
	// The two-letter code for the country of the address.
	//
	// For example, US.
	CountryCode *string `json:"countryCode"`
	// The two-letter code for the country of the address.
	//
	// For example, US.
	CountryCodeV2 *CountryCode `json:"countryCodeV2"`
	// The first name of the customer.
	FirstName *string `json:"firstName"`
	// A formatted version of the address, customized by the provided arguments.
	Formatted []string `json:"formatted"`
	// A comma-separated list of the values for city, province, and country.
	FormattedArea *string `json:"formattedArea"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The last name of the customer.
	LastName *string `json:"lastName"`
	// The latitude coordinate of the customer address.
	Latitude *float64 `json:"latitude"`
	// The longitude coordinate of the customer address.
	Longitude *float64 `json:"longitude"`
	// The full name of the customer, based on firstName and lastName.
	Name *string `json:"name"`
	// A unique phone number for the customer.
	//
	// Formatted using E.164 standard. For example, _+16135551111_.
	Phone *string `json:"phone"`
	// The region of the address, such as the province, state, or district.
	Province *string `json:"province"`
	// The two-letter code for the region.
	//
	// For example, ON.
	ProvinceCode *string `json:"provinceCode"`
	// The zip or postal code of the address.
	Zip *string `json:"zip"`
}

func (MailingAddress) IsNode() {}

// An auto-generated type for paginating through multiple MailingAddresses.
type MailingAddressConnection struct {
	// A list of edges.
	Edges []*MailingAddressEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one MailingAddress and a cursor during pagination.
type MailingAddressEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of MailingAddressEdge.
	Node *MailingAddress `json:"node"`
}

// Specifies the fields accepted to create or update a mailing address.
type MailingAddressInput struct {
	// The first line of the address. Typically the street address or PO Box number.
	Address1 *string `json:"address1"`
	// The second line of the address. Typically the number of the apartment, suite, or unit.
	Address2 *string `json:"address2"`
	// The name of the city, district, village, or town.
	City *string `json:"city"`
	// The name of the customer's company or organization.
	Company *string `json:"company"`
	// The name of the country.
	Country *string `json:"country"`
	// The first name of the customer.
	FirstName *string `json:"firstName"`
	// The last name of the customer.
	LastName *string `json:"lastName"`
	// A unique phone number for the customer.
	//
	// Formatted using E.164 standard. For example, _+16135551111_.
	Phone *string `json:"phone"`
	// The region of the address, such as the province, state, or district.
	Province *string `json:"province"`
	// The zip or postal code of the address.
	Zip *string `json:"zip"`
}

// Manual discount applications capture the intentions of a discount that was manually created.
type ManualDiscountApplication struct {
	// The method by which the discount's value is allocated to its entitled items.
	AllocationMethod DiscountApplicationAllocationMethod `json:"allocationMethod"`
	// The description of the application.
	Description *string `json:"description"`
	// Which lines of targetType that the discount is allocated over.
	TargetSelection DiscountApplicationTargetSelection `json:"targetSelection"`
	// The type of line that the discount is applicable towards.
	TargetType DiscountApplicationTargetType `json:"targetType"`
	// The title of the application.
	Title string `json:"title"`
	// The value of the discount application.
	Value PricingValue `json:"value"`
}

func (ManualDiscountApplication) IsDiscountApplication() {}

// Metafields represent custom metadata attached to a resource. Metafields can be sorted into namespaces and are
// comprised of keys, values, and value types.
type Metafield struct {
	// The description of a metafield.
	Description *string `json:"description"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The key name for a metafield.
	Key string `json:"key"`
	// The namespace for a metafield.
	Namespace string `json:"namespace"`
	// The parent object that the metafield belongs to.
	ParentResource MetafieldParentResource `json:"parentResource"`
	// The value of a metafield.
	Value string `json:"value"`
	// Represents the metafield value type.
	ValueType MetafieldValueType `json:"valueType"`
}

func (Metafield) IsNode() {}

// An auto-generated type for paginating through multiple Metafields.
type MetafieldConnection struct {
	// A list of edges.
	Edges []*MetafieldEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one Metafield and a cursor during pagination.
type MetafieldEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of MetafieldEdge.
	Node *Metafield `json:"node"`
}

// Specifies the fields for a monetary value with currency.
type MoneyInput struct {
	// Decimal money amount.
	Amount string `json:"amount"`
	// Currency of the money.
	CurrencyCode CurrencyCode `json:"currencyCode"`
}

// A monetary value with currency.
//
// To format currencies, combine this type's amount and currencyCode fields with your client's locale.
//
// For example, in JavaScript you could use Intl.NumberFormat:
//
// ```js
// new Intl.NumberFormat(locale, {
//   style: 'currency',
//   currency: currencyCode
// }).format(amount);
// ```
//
// Other formatting libraries include:
//
// * iOS - [NumberFormatter](https://developer.apple.com/documentation/foundation/numberformatter)
// * Android - [NumberFormat](https://developer.android.com/reference/java/text/NumberFormat.html)
// * PHP - [NumberFormatter](http://php.net/manual/en/class.numberformatter.php)
//
// For a more general solution, the [Unicode CLDR number formatting database] is available with many implementations
// (such as [TwitterCldr](https://github.com/twitter/twitter-cldr-rb)).
type MoneyV2 struct {
	// Decimal money amount.
	Amount string `json:"amount"`
	// Currency of the money.
	CurrencyCode CurrencyCode `json:"currencyCode"`
}

func (MoneyV2) IsPricingValue() {}

// An order is a customer’s completed request to purchase one or more products from a shop. An order is created when a customer completes the checkout process, during which time they provides an email address, billing address and payment information.
type Order struct {
	// The code of the currency used for the payment.
	CurrencyCode CurrencyCode `json:"currencyCode"`
	// The locale code in which this specific order happened.
	CustomerLocale *string `json:"customerLocale"`
	// The unique URL that the customer can use to access the order.
	CustomerURL *string `json:"customerUrl"`
	// Discounts that have been applied on the order.
	DiscountApplications *DiscountApplicationConnection `json:"discountApplications"`
	// The customer's email address.
	Email *string `json:"email"`
	// Globally unique identifier.
	ID string `json:"id"`
	// List of the order’s line items.
	LineItems *OrderLineItemConnection `json:"lineItems"`
	// Unique identifier for the order that appears on the order.
	// For example, _#1000_ or _Store1001.
	Name string `json:"name"`
	// A unique numeric identifier for the order for use by shop owner and customer.
	OrderNumber int `json:"orderNumber"`
	// The customer's phone number for receiving SMS notifications.
	Phone *string `json:"phone"`
	// The date and time when the order was imported.
	// This value can be set to dates in the past when importing from other systems.
	// If no value is provided, it will be auto-generated based on current date and time.
	ProcessedAt string `json:"processedAt"`
	// The address to where the order will be shipped.
	ShippingAddress *MailingAddress `json:"shippingAddress"`
	// The discounts that have been allocated onto the shipping line by discount applications.
	ShippingDiscountAllocations []*DiscountAllocation `json:"shippingDiscountAllocations"`
	// The unique URL for the order's status page.
	StatusURL string `json:"statusUrl"`
	// Price of the order before shipping and taxes.
	SubtotalPrice *string `json:"subtotalPrice"`
	// Price of the order before duties, shipping and taxes.
	SubtotalPriceV2 *MoneyV2 `json:"subtotalPriceV2"`
	// List of the order’s successful fulfillments.
	SuccessfulFulfillments []*Fulfillment `json:"successfulFulfillments"`
	// The sum of all the prices of all the items in the order, taxes and discounts included (must be positive).
	TotalPrice string `json:"totalPrice"`
	// The sum of all the prices of all the items in the order, duties, taxes and discounts included (must be positive).
	TotalPriceV2 *MoneyV2 `json:"totalPriceV2"`
	// The total amount that has been refunded.
	TotalRefunded string `json:"totalRefunded"`
	// The total amount that has been refunded.
	TotalRefundedV2 *MoneyV2 `json:"totalRefundedV2"`
	// The total cost of shipping.
	TotalShippingPrice string `json:"totalShippingPrice"`
	// The total cost of shipping.
	TotalShippingPriceV2 *MoneyV2 `json:"totalShippingPriceV2"`
	// The total cost of taxes.
	TotalTax *string `json:"totalTax"`
	// The total cost of taxes.
	TotalTaxV2 *MoneyV2 `json:"totalTaxV2"`
}

func (Order) IsNode() {}

// An auto-generated type for paginating through multiple Orders.
type OrderConnection struct {
	// A list of edges.
	Edges []*OrderEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one Order and a cursor during pagination.
type OrderEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of OrderEdge.
	Node *Order `json:"node"`
}

// Represents a single line in an order. There is one line item for each distinct product variant.
type OrderLineItem struct {
	// List of custom attributes associated to the line item.
	CustomAttributes []*Attribute `json:"customAttributes"`
	// The discounts that have been allocated onto the order line item by discount applications.
	DiscountAllocations []*DiscountAllocation `json:"discountAllocations"`
	// The number of products variants associated to the line item.
	Quantity int `json:"quantity"`
	// The title of the product combined with title of the variant.
	Title string `json:"title"`
	// The product variant object associated to the line item.
	Variant *ProductVariant `json:"variant"`
}

// An auto-generated type for paginating through multiple OrderLineItems.
type OrderLineItemConnection struct {
	// A list of edges.
	Edges []*OrderLineItemEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one OrderLineItem and a cursor during pagination.
type OrderLineItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of OrderLineItemEdge.
	Node *OrderLineItem `json:"node"`
}

// Shopify merchants can create pages to hold static HTML content. Each Page object represents a custom page on the online store.
type Page struct {
	// The description of the page, complete with HTML formatting.
	Body string `json:"body"`
	// Summary of the page body.
	BodySummary string `json:"bodySummary"`
	// The timestamp of the page creation.
	CreatedAt string `json:"createdAt"`
	// A human-friendly unique string for the page automatically generated from its title.
	Handle string `json:"handle"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The title of the page.
	Title string `json:"title"`
	// The timestamp of the latest page update.
	UpdatedAt string `json:"updatedAt"`
	// The url pointing to the page accessible from the web.
	URL string `json:"url"`
}

func (Page) IsNode() {}

// An auto-generated type for paginating through multiple Pages.
type PageConnection struct {
	// A list of edges.
	Edges []*PageEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one Page and a cursor during pagination.
type PageEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of PageEdge.
	Node *Page `json:"node"`
}

// Information about pagination in a connection.
type PageInfo struct {
	// Indicates if there are more pages to fetch.
	HasNextPage bool `json:"hasNextPage"`
	// Indicates if there are any pages prior to the current page.
	HasPreviousPage bool `json:"hasPreviousPage"`
}

// A payment applied to a checkout.
type Payment struct {
	// The amount of the payment.
	Amount string `json:"amount"`
	// The amount of the payment.
	AmountV2 *MoneyV2 `json:"amountV2"`
	// The billing address for the payment.
	BillingAddress *MailingAddress `json:"billingAddress"`
	// The checkout to which the payment belongs.
	Checkout *Checkout `json:"checkout"`
	// The credit card used for the payment in the case of direct payments.
	CreditCard *CreditCard `json:"creditCard"`
	// A message describing a processing error during asynchronous processing.
	ErrorMessage *string `json:"errorMessage"`
	// Globally unique identifier.
	ID string `json:"id"`
	// A client-side generated token to identify a payment and perform idempotent operations.
	IdempotencyKey *string `json:"idempotencyKey"`
	// Whether or not the payment is still processing asynchronously.
	Ready bool `json:"ready"`
	// A flag to indicate if the payment is to be done in test mode for gateways that support it.
	Test bool `json:"test"`
	// The actual transaction recorded by Shopify after having processed the payment with the gateway.
	Transaction *Transaction `json:"transaction"`
}

func (Payment) IsNode() {}

// Settings related to payments.
type PaymentSettings struct {
	// List of the card brands which the shop accepts.
	AcceptedCardBrands []CardBrand `json:"acceptedCardBrands"`
	// The url pointing to the endpoint to vault credit cards.
	CardVaultURL string `json:"cardVaultUrl"`
	// The country where the shop is located.
	CountryCode CountryCode `json:"countryCode"`
	// The three-letter code for the shop's primary currency.
	CurrencyCode CurrencyCode `json:"currencyCode"`
	// A list of enabled currencies (ISO 4217 format) that the shop accepts. Merchants can enable currencies from their Shopify Payments settings in the Shopify admin.
	EnabledPresentmentCurrencies []CurrencyCode `json:"enabledPresentmentCurrencies"`
	// The shop’s Shopify Payments account id.
	ShopifyPaymentsAccountID *string `json:"shopifyPaymentsAccountId"`
	// List of the digital wallets which the shop supports.
	SupportedDigitalWallets []DigitalWallet `json:"supportedDigitalWallets"`
}

// The value of the percentage pricing object.
type PricingPercentageValue struct {
	// The percentage value of the object.
	Percentage float64 `json:"percentage"`
}

func (PricingPercentageValue) IsPricingValue() {}

// A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
// For example, a digital download (such as a movie, music or ebook file) also qualifies as a product, as do services (such as equipment rental, work for hire, customization of another product or an extended warranty).
type Product struct {
	// Indicates if at least one product variant is available for sale.
	AvailableForSale bool `json:"availableForSale"`
	// List of collections a product belongs to.
	Collections *CollectionConnection `json:"collections"`
	// The date and time when the product was created.
	CreatedAt string `json:"createdAt"`
	// Stripped description of the product, single line with HTML tags removed.
	Description string `json:"description"`
	// The description of the product, complete with HTML formatting.
	DescriptionHTML string `json:"descriptionHtml"`
	// A human-friendly unique string for the Product automatically generated from its title.
	// They are used by the Liquid templating language to refer to objects.
	Handle string `json:"handle"`
	// Globally unique identifier.
	ID string `json:"id"`
	// List of images associated with the product.
	Images *ImageConnection `json:"images"`
	// The metafield associated with the resource.
	Metafield *Metafield `json:"metafield"`
	// A paginated list of metafields associated with the resource.
	Metafields *MetafieldConnection `json:"metafields"`
	// The online store URL for the product.
	// A value of `null` indicates that the product is not published to the Online Store sales channel.
	OnlineStoreURL *string `json:"onlineStoreUrl"`
	// List of product options.
	Options []*ProductOption `json:"options"`
	// List of price ranges in the presentment currencies for this shop.
	PresentmentPriceRanges *ProductPriceRangeConnection `json:"presentmentPriceRanges"`
	// The price range.
	PriceRange *ProductPriceRange `json:"priceRange"`
	// A categorization that a product can be tagged with, commonly used for filtering and searching.
	ProductType string `json:"productType"`
	// The date and time when the product was published to the channel.
	PublishedAt string `json:"publishedAt"`
	// A comma separated list of tags that have been added to the product.
	// Additional access scope required for private apps: unauthenticated_read_product_tags.
	Tags []string `json:"tags"`
	// The product’s title.
	Title string `json:"title"`
	// The date and time when the product was last modified.
	// A product's `updatedAt` value can change for different reasons. For example, if an order
	// is placed for a product that has inventory tracking set up, then the inventory adjustment
	// is counted as an update.
	UpdatedAt string `json:"updatedAt"`
	// Find a product’s variant based on its selected options.
	// This is useful for converting a user’s selection of product options into a single matching variant.
	// If there is not a variant for the selected options, `null` will be returned.
	VariantBySelectedOptions *ProductVariant `json:"variantBySelectedOptions"`
	// List of the product’s variants.
	Variants *ProductVariantConnection `json:"variants"`
	// The product’s vendor name.
	Vendor string `json:"vendor"`
}

func (Product) IsMetafieldParentResource() {}
func (Product) IsNode()                    {}
func (Product) IsHasMetafields()           {}

// An auto-generated type for paginating through multiple Products.
type ProductConnection struct {
	// A list of edges.
	Edges []*ProductEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one Product and a cursor during pagination.
type ProductEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ProductEdge.
	Node *Product `json:"node"`
}

// Product property names like "Size", "Color", and "Material" that the customers can select.
// Variants are selected based on permutations of these options.
// 255 characters limit each.
type ProductOption struct {
	// Globally unique identifier.
	ID string `json:"id"`
	// The product option’s name.
	Name string `json:"name"`
	// The corresponding value to the product option name.
	Values []string `json:"values"`
}

func (ProductOption) IsNode() {}

// The price range of the product.
type ProductPriceRange struct {
	// The highest variant's price.
	MaxVariantPrice *MoneyV2 `json:"maxVariantPrice"`
	// The lowest variant's price.
	MinVariantPrice *MoneyV2 `json:"minVariantPrice"`
}

// An auto-generated type for paginating through multiple ProductPriceRanges.
type ProductPriceRangeConnection struct {
	// A list of edges.
	Edges []*ProductPriceRangeEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one ProductPriceRange and a cursor during pagination.
type ProductPriceRangeEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ProductPriceRangeEdge.
	Node *ProductPriceRange `json:"node"`
}

// A product variant represents a different version of a product, such as differing sizes or differing colors.
type ProductVariant struct {
	// Indicates if the product variant is in stock.
	Available *bool `json:"available"`
	// Indicates if the product variant is available for sale.
	AvailableForSale bool `json:"availableForSale"`
	// The compare at price of the variant. This can be used to mark a variant as on sale, when `compareAtPrice` is higher than `price`.
	CompareAtPrice *string `json:"compareAtPrice"`
	// The compare at price of the variant. This can be used to mark a variant as on sale, when `compareAtPriceV2` is higher than `priceV2`.
	CompareAtPriceV2 *MoneyV2 `json:"compareAtPriceV2"`
	// Globally unique identifier.
	ID string `json:"id"`
	// Image associated with the product variant. This field falls back to the product image if no image is available.
	Image *Image `json:"image"`
	// The metafield associated with the resource.
	Metafield *Metafield `json:"metafield"`
	// A paginated list of metafields associated with the resource.
	Metafields *MetafieldConnection `json:"metafields"`
	// List of prices and compare-at prices in the presentment currencies for this shop.
	PresentmentPrices *ProductVariantPricePairConnection `json:"presentmentPrices"`
	// The product variant’s price.
	Price string `json:"price"`
	// The product variant’s price.
	PriceV2 *MoneyV2 `json:"priceV2"`
	// The product object that the product variant belongs to.
	Product *Product `json:"product"`
	// Whether a customer needs to provide a shipping address when placing an order for the product variant.
	RequiresShipping bool `json:"requiresShipping"`
	// List of product options applied to the variant.
	SelectedOptions []*SelectedOption `json:"selectedOptions"`
	// The SKU (stock keeping unit) associated with the variant.
	Sku *string `json:"sku"`
	// The product variant’s title.
	Title string `json:"title"`
	// The weight of the product variant in the unit system specified with `weight_unit`.
	Weight *float64 `json:"weight"`
	// Unit of measurement for weight.
	WeightUnit WeightUnit `json:"weightUnit"`
}

func (ProductVariant) IsMetafieldParentResource() {}
func (ProductVariant) IsNode()                    {}
func (ProductVariant) IsHasMetafields()           {}

// An auto-generated type for paginating through multiple ProductVariants.
type ProductVariantConnection struct {
	// A list of edges.
	Edges []*ProductVariantEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one ProductVariant and a cursor during pagination.
type ProductVariantEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ProductVariantEdge.
	Node *ProductVariant `json:"node"`
}

// The compare-at price and price of a variant sharing a currency.
type ProductVariantPricePair struct {
	// The compare-at price of the variant with associated currency.
	CompareAtPrice *MoneyV2 `json:"compareAtPrice"`
	// The price of the variant with associated currency.
	Price *MoneyV2 `json:"price"`
}

// An auto-generated type for paginating through multiple ProductVariantPricePairs.
type ProductVariantPricePairConnection struct {
	// A list of edges.
	Edges []*ProductVariantPricePairEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one ProductVariantPricePair and a cursor during pagination.
type ProductVariantPricePairEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ProductVariantPricePairEdge.
	Node *ProductVariantPricePair `json:"node"`
}

// SEO information.
type Seo struct {
	// The meta description.
	Description *string `json:"description"`
	// The SEO title.
	Title *string `json:"title"`
}

// Script discount applications capture the intentions of a discount that
// was created by a Shopify Script.
type ScriptDiscountApplication struct {
	// The method by which the discount's value is allocated to its entitled items.
	AllocationMethod DiscountApplicationAllocationMethod `json:"allocationMethod"`
	// The description of the application as defined by the Script.
	Description string `json:"description"`
	// Which lines of targetType that the discount is allocated over.
	TargetSelection DiscountApplicationTargetSelection `json:"targetSelection"`
	// The type of line that the discount is applicable towards.
	TargetType DiscountApplicationTargetType `json:"targetType"`
	// The title of the application as defined by the Script.
	Title string `json:"title"`
	// The value of the discount application.
	Value PricingValue `json:"value"`
}

func (ScriptDiscountApplication) IsDiscountApplication() {}

// Properties used by customers to select a product variant.
// Products can have multiple options, like different sizes or colors.
type SelectedOption struct {
	// The product option’s name.
	Name string `json:"name"`
	// The product option’s value.
	Value string `json:"value"`
}

// Specifies the input fields required for a selected option.
type SelectedOptionInput struct {
	// The product option’s name.
	Name string `json:"name"`
	// The product option’s value.
	Value string `json:"value"`
}

// A shipping rate to be applied to a checkout.
type ShippingRate struct {
	// Human-readable unique identifier for this shipping rate.
	Handle string `json:"handle"`
	// Price of this shipping rate.
	Price string `json:"price"`
	// Price of this shipping rate.
	PriceV2 *MoneyV2 `json:"priceV2"`
	// Title of this shipping rate.
	Title string `json:"title"`
}

// Shop represents a collection of the general settings and information about the shop.
type Shop struct {
	// List of the shop' articles.
	Articles *ArticleConnection `json:"articles"`
	// List of the shop' blogs.
	Blogs *BlogConnection `json:"blogs"`
	// Find a collection by its handle.
	CollectionByHandle *Collection `json:"collectionByHandle"`
	// List of the shop’s collections.
	Collections *CollectionConnection `json:"collections"`
	// The three-letter code for the currency that the shop accepts.
	CurrencyCode CurrencyCode `json:"currencyCode"`
	// A description of the shop.
	Description *string `json:"description"`
	// A string representing the way currency is formatted when the currency isn’t specified.
	MoneyFormat string `json:"moneyFormat"`
	// The shop’s name.
	Name string `json:"name"`
	// Settings related to payments.
	PaymentSettings *PaymentSettings `json:"paymentSettings"`
	// The shop’s primary domain.
	PrimaryDomain *Domain `json:"primaryDomain"`
	// The shop’s privacy policy.
	PrivacyPolicy *ShopPolicy `json:"privacyPolicy"`
	// Find a product by its handle.
	ProductByHandle *Product `json:"productByHandle"`
	// A list of tags that have been added to products.
	// Additional access scope required: unauthenticated_read_product_tags.
	ProductTags *StringConnection `json:"productTags"`
	// List of the shop’s product types.
	ProductTypes *StringConnection `json:"productTypes"`
	// List of the shop’s products.
	Products *ProductConnection `json:"products"`
	// The shop’s refund policy.
	RefundPolicy *ShopPolicy `json:"refundPolicy"`
	// Countries that the shop ships to.
	ShipsToCountries []CountryCode `json:"shipsToCountries"`
	// The shop’s Shopify Payments account id.
	ShopifyPaymentsAccountID *string `json:"shopifyPaymentsAccountId"`
	// The shop’s terms of service.
	TermsOfService *ShopPolicy `json:"termsOfService"`
}

// Policy that a merchant has configured for their store, such as their refund or privacy policy.
type ShopPolicy struct {
	// Policy text, maximum size of 64kb.
	Body string `json:"body"`
	// Policy’s handle.
	Handle string `json:"handle"`
	// Globally unique identifier.
	ID string `json:"id"`
	// Policy’s title.
	Title string `json:"title"`
	// Public URL to the policy.
	URL string `json:"url"`
}

func (ShopPolicy) IsNode() {}

// An auto-generated type for paginating through multiple Strings.
type StringConnection struct {
	// A list of edges.
	Edges []*StringEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one String and a cursor during pagination.
type StringEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of StringEdge.
	Node string `json:"node"`
}

// Specifies the fields required to complete a checkout with
// a tokenized payment.
type TokenizedPaymentInput struct {
	// The amount of the payment.
	Amount string `json:"amount"`
	// A unique client generated key used to avoid duplicate charges. When a duplicate payment is found, the original is returned instead of creating a new one.
	IdempotencyKey string `json:"idempotencyKey"`
	// The billing address for the payment.
	BillingAddress *MailingAddressInput `json:"billingAddress"`
	// The type of payment token.
	Type string `json:"type"`
	// A simple string or JSON containing the required payment data for the tokenized payment.
	PaymentData string `json:"paymentData"`
	// Executes the payment in test mode if possible. Defaults to `false`.
	Test *bool `json:"test"`
	// Public Hash Key used for AndroidPay payments only.
	Identifier *string `json:"identifier"`
}

// Specifies the fields required to complete a checkout with
// a tokenized payment.
type TokenizedPaymentInputV2 struct {
	// The amount and currency of the payment.
	PaymentAmount *MoneyInput `json:"paymentAmount"`
	// A unique client generated key used to avoid duplicate charges. When a duplicate payment is found, the original is returned instead of creating a new one.
	IdempotencyKey string `json:"idempotencyKey"`
	// The billing address for the payment.
	BillingAddress *MailingAddressInput `json:"billingAddress"`
	// A simple string or JSON containing the required payment data for the tokenized payment.
	PaymentData string `json:"paymentData"`
	// Whether to execute the payment in test mode, if possible. Test mode is not supported in production stores. Defaults to `false`.
	Test *bool `json:"test"`
	// Public Hash Key used for AndroidPay payments only.
	Identifier *string `json:"identifier"`
	// The type of payment token.
	Type string `json:"type"`
}

// An object representing exchange of money for a product or service.
type Transaction struct {
	// The amount of money that the transaction was for.
	Amount string `json:"amount"`
	// The amount of money that the transaction was for.
	AmountV2 *MoneyV2 `json:"amountV2"`
	// The kind of the transaction.
	Kind TransactionKind `json:"kind"`
	// The status of the transaction.
	Status TransactionStatus `json:"status"`
	// The status of the transaction.
	StatusV2 *TransactionStatus `json:"statusV2"`
	// Whether the transaction was done in test mode or not.
	Test bool `json:"test"`
}

// Represents an error in the input of a mutation.
type UserError struct {
	// Path to the input field which caused the error.
	Field []string `json:"field"`
	// The error message.
	Message string `json:"message"`
}

func (UserError) IsDisplayableError() {}

// The set of valid sort keys for the Article query.
type ArticleSortKeys string

const (
	// Sort by the `title` value.
	ArticleSortKeysTitle ArticleSortKeys = "TITLE"
	// Sort by the `blog_title` value.
	ArticleSortKeysBlogTitle ArticleSortKeys = "BLOG_TITLE"
	// Sort by the `author` value.
	ArticleSortKeysAuthor ArticleSortKeys = "AUTHOR"
	// Sort by the `updated_at` value.
	ArticleSortKeysUpdatedAt ArticleSortKeys = "UPDATED_AT"
	// Sort by the `published_at` value.
	ArticleSortKeysPublishedAt ArticleSortKeys = "PUBLISHED_AT"
	// Sort by the `id` value.
	ArticleSortKeysID ArticleSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	ArticleSortKeysRelevance ArticleSortKeys = "RELEVANCE"
)

var AllArticleSortKeys = []ArticleSortKeys{
	ArticleSortKeysTitle,
	ArticleSortKeysBlogTitle,
	ArticleSortKeysAuthor,
	ArticleSortKeysUpdatedAt,
	ArticleSortKeysPublishedAt,
	ArticleSortKeysID,
	ArticleSortKeysRelevance,
}

func (e ArticleSortKeys) IsValid() bool {
	switch e {
	case ArticleSortKeysTitle, ArticleSortKeysBlogTitle, ArticleSortKeysAuthor, ArticleSortKeysUpdatedAt, ArticleSortKeysPublishedAt, ArticleSortKeysID, ArticleSortKeysRelevance:
		return true
	}
	return false
}

func (e ArticleSortKeys) String() string {
	return string(e)
}

func (e *ArticleSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ArticleSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ArticleSortKeys", str)
	}
	return nil
}

func (e ArticleSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the Blog query.
type BlogSortKeys string

const (
	// Sort by the `handle` value.
	BlogSortKeysHandle BlogSortKeys = "HANDLE"
	// Sort by the `title` value.
	BlogSortKeysTitle BlogSortKeys = "TITLE"
	// Sort by the `id` value.
	BlogSortKeysID BlogSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	BlogSortKeysRelevance BlogSortKeys = "RELEVANCE"
)

var AllBlogSortKeys = []BlogSortKeys{
	BlogSortKeysHandle,
	BlogSortKeysTitle,
	BlogSortKeysID,
	BlogSortKeysRelevance,
}

func (e BlogSortKeys) IsValid() bool {
	switch e {
	case BlogSortKeysHandle, BlogSortKeysTitle, BlogSortKeysID, BlogSortKeysRelevance:
		return true
	}
	return false
}

func (e BlogSortKeys) String() string {
	return string(e)
}

func (e *BlogSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BlogSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BlogSortKeys", str)
	}
	return nil
}

func (e BlogSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Card brand, such as Visa or Mastercard, which can be used for payments.
type CardBrand string

const (
	// Visa
	CardBrandVisa CardBrand = "VISA"
	// Mastercard
	CardBrandMastercard CardBrand = "MASTERCARD"
	// Discover
	CardBrandDiscover CardBrand = "DISCOVER"
	// American Express
	CardBrandAmericanExpress CardBrand = "AMERICAN_EXPRESS"
	// Diners Club
	CardBrandDinersClub CardBrand = "DINERS_CLUB"
	// JCB
	CardBrandJcb CardBrand = "JCB"
)

var AllCardBrand = []CardBrand{
	CardBrandVisa,
	CardBrandMastercard,
	CardBrandDiscover,
	CardBrandAmericanExpress,
	CardBrandDinersClub,
	CardBrandJcb,
}

func (e CardBrand) IsValid() bool {
	switch e {
	case CardBrandVisa, CardBrandMastercard, CardBrandDiscover, CardBrandAmericanExpress, CardBrandDinersClub, CardBrandJcb:
		return true
	}
	return false
}

func (e CardBrand) String() string {
	return string(e)
}

func (e *CardBrand) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CardBrand(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CardBrand", str)
	}
	return nil
}

func (e CardBrand) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes that could be returned by CheckoutUserError.
type CheckoutErrorCode string

const (
	// Input value is blank.
	CheckoutErrorCodeBlank CheckoutErrorCode = "BLANK"
	// Input value is invalid.
	CheckoutErrorCodeInvalid CheckoutErrorCode = "INVALID"
	// Input value is too long.
	CheckoutErrorCodeTooLong CheckoutErrorCode = "TOO_LONG"
	// Input value is not present.
	CheckoutErrorCodePresent CheckoutErrorCode = "PRESENT"
	// Input value should be less than maximum allowed value.
	CheckoutErrorCodeLessThan CheckoutErrorCode = "LESS_THAN"
	// Input value should be greater than or equal to minimum allowed value.
	CheckoutErrorCodeGreaterThanOrEqualTo CheckoutErrorCode = "GREATER_THAN_OR_EQUAL_TO"
	// Input value should be less or equal to maximum allowed value.
	CheckoutErrorCodeLessThanOrEqualTo CheckoutErrorCode = "LESS_THAN_OR_EQUAL_TO"
	// Checkout is already completed.
	CheckoutErrorCodeAlreadyCompleted CheckoutErrorCode = "ALREADY_COMPLETED"
	// Checkout is locked.
	CheckoutErrorCodeLocked CheckoutErrorCode = "LOCKED"
	// Input value is not supported.
	CheckoutErrorCodeNotSupported CheckoutErrorCode = "NOT_SUPPORTED"
	// Input email contains an invalid domain name.
	CheckoutErrorCodeBadDomain CheckoutErrorCode = "BAD_DOMAIN"
	// Input Zip is invalid for country provided.
	CheckoutErrorCodeInvalidForCountry CheckoutErrorCode = "INVALID_FOR_COUNTRY"
	// Input Zip is invalid for country and province provided.
	CheckoutErrorCodeInvalidForCountryAndProvince CheckoutErrorCode = "INVALID_FOR_COUNTRY_AND_PROVINCE"
	// Invalid state in country.
	CheckoutErrorCodeInvalidStateInCountry CheckoutErrorCode = "INVALID_STATE_IN_COUNTRY"
	// Invalid province in country.
	CheckoutErrorCodeInvalidProvinceInCountry CheckoutErrorCode = "INVALID_PROVINCE_IN_COUNTRY"
	// Invalid region in country.
	CheckoutErrorCodeInvalidRegionInCountry CheckoutErrorCode = "INVALID_REGION_IN_COUNTRY"
	// Shipping rate expired.
	CheckoutErrorCodeShippingRateExpired CheckoutErrorCode = "SHIPPING_RATE_EXPIRED"
	// Gift card cannot be applied to a checkout that contains a gift card.
	CheckoutErrorCodeGiftCardUnusable CheckoutErrorCode = "GIFT_CARD_UNUSABLE"
	// Gift card is disabled.
	CheckoutErrorCodeGiftCardDisabled CheckoutErrorCode = "GIFT_CARD_DISABLED"
	// Gift card code is invalid.
	CheckoutErrorCodeGiftCardCodeInvalid CheckoutErrorCode = "GIFT_CARD_CODE_INVALID"
	// Gift card has already been applied.
	CheckoutErrorCodeGiftCardAlreadyApplied CheckoutErrorCode = "GIFT_CARD_ALREADY_APPLIED"
	// Gift card currency does not match checkout currency.
	CheckoutErrorCodeGiftCardCurrencyMismatch CheckoutErrorCode = "GIFT_CARD_CURRENCY_MISMATCH"
	// Gift card is expired.
	CheckoutErrorCodeGiftCardExpired CheckoutErrorCode = "GIFT_CARD_EXPIRED"
	// Gift card has no funds left.
	CheckoutErrorCodeGiftCardDepleted CheckoutErrorCode = "GIFT_CARD_DEPLETED"
	// Gift card was not found.
	CheckoutErrorCodeGiftCardNotFound CheckoutErrorCode = "GIFT_CARD_NOT_FOUND"
	// Cart does not meet discount requirements notice.
	CheckoutErrorCodeCartDoesNotMeetDiscountRequirementsNotice CheckoutErrorCode = "CART_DOES_NOT_MEET_DISCOUNT_REQUIREMENTS_NOTICE"
	// Discount expired.
	CheckoutErrorCodeDiscountExpired CheckoutErrorCode = "DISCOUNT_EXPIRED"
	// Discount disabled.
	CheckoutErrorCodeDiscountDisabled CheckoutErrorCode = "DISCOUNT_DISABLED"
	// Discount limit reached.
	CheckoutErrorCodeDiscountLimitReached CheckoutErrorCode = "DISCOUNT_LIMIT_REACHED"
	// Discount not found.
	CheckoutErrorCodeDiscountNotFound CheckoutErrorCode = "DISCOUNT_NOT_FOUND"
	// Customer already used once per customer discount notice.
	CheckoutErrorCodeCustomerAlreadyUsedOncePerCustomerDiscountNotice CheckoutErrorCode = "CUSTOMER_ALREADY_USED_ONCE_PER_CUSTOMER_DISCOUNT_NOTICE"
	// Checkout is already completed.
	CheckoutErrorCodeEmpty CheckoutErrorCode = "EMPTY"
	// Not enough in stock.
	CheckoutErrorCodeNotEnoughInStock CheckoutErrorCode = "NOT_ENOUGH_IN_STOCK"
	// Missing payment input.
	CheckoutErrorCodeMissingPaymentInput CheckoutErrorCode = "MISSING_PAYMENT_INPUT"
	// The amount of the payment does not match the value to be paid.
	CheckoutErrorCodeTotalPriceMismatch CheckoutErrorCode = "TOTAL_PRICE_MISMATCH"
	// Line item was not found in checkout.
	CheckoutErrorCodeLineItemNotFound CheckoutErrorCode = "LINE_ITEM_NOT_FOUND"
)

var AllCheckoutErrorCode = []CheckoutErrorCode{
	CheckoutErrorCodeBlank,
	CheckoutErrorCodeInvalid,
	CheckoutErrorCodeTooLong,
	CheckoutErrorCodePresent,
	CheckoutErrorCodeLessThan,
	CheckoutErrorCodeGreaterThanOrEqualTo,
	CheckoutErrorCodeLessThanOrEqualTo,
	CheckoutErrorCodeAlreadyCompleted,
	CheckoutErrorCodeLocked,
	CheckoutErrorCodeNotSupported,
	CheckoutErrorCodeBadDomain,
	CheckoutErrorCodeInvalidForCountry,
	CheckoutErrorCodeInvalidForCountryAndProvince,
	CheckoutErrorCodeInvalidStateInCountry,
	CheckoutErrorCodeInvalidProvinceInCountry,
	CheckoutErrorCodeInvalidRegionInCountry,
	CheckoutErrorCodeShippingRateExpired,
	CheckoutErrorCodeGiftCardUnusable,
	CheckoutErrorCodeGiftCardDisabled,
	CheckoutErrorCodeGiftCardCodeInvalid,
	CheckoutErrorCodeGiftCardAlreadyApplied,
	CheckoutErrorCodeGiftCardCurrencyMismatch,
	CheckoutErrorCodeGiftCardExpired,
	CheckoutErrorCodeGiftCardDepleted,
	CheckoutErrorCodeGiftCardNotFound,
	CheckoutErrorCodeCartDoesNotMeetDiscountRequirementsNotice,
	CheckoutErrorCodeDiscountExpired,
	CheckoutErrorCodeDiscountDisabled,
	CheckoutErrorCodeDiscountLimitReached,
	CheckoutErrorCodeDiscountNotFound,
	CheckoutErrorCodeCustomerAlreadyUsedOncePerCustomerDiscountNotice,
	CheckoutErrorCodeEmpty,
	CheckoutErrorCodeNotEnoughInStock,
	CheckoutErrorCodeMissingPaymentInput,
	CheckoutErrorCodeTotalPriceMismatch,
	CheckoutErrorCodeLineItemNotFound,
}

func (e CheckoutErrorCode) IsValid() bool {
	switch e {
	case CheckoutErrorCodeBlank, CheckoutErrorCodeInvalid, CheckoutErrorCodeTooLong, CheckoutErrorCodePresent, CheckoutErrorCodeLessThan, CheckoutErrorCodeGreaterThanOrEqualTo, CheckoutErrorCodeLessThanOrEqualTo, CheckoutErrorCodeAlreadyCompleted, CheckoutErrorCodeLocked, CheckoutErrorCodeNotSupported, CheckoutErrorCodeBadDomain, CheckoutErrorCodeInvalidForCountry, CheckoutErrorCodeInvalidForCountryAndProvince, CheckoutErrorCodeInvalidStateInCountry, CheckoutErrorCodeInvalidProvinceInCountry, CheckoutErrorCodeInvalidRegionInCountry, CheckoutErrorCodeShippingRateExpired, CheckoutErrorCodeGiftCardUnusable, CheckoutErrorCodeGiftCardDisabled, CheckoutErrorCodeGiftCardCodeInvalid, CheckoutErrorCodeGiftCardAlreadyApplied, CheckoutErrorCodeGiftCardCurrencyMismatch, CheckoutErrorCodeGiftCardExpired, CheckoutErrorCodeGiftCardDepleted, CheckoutErrorCodeGiftCardNotFound, CheckoutErrorCodeCartDoesNotMeetDiscountRequirementsNotice, CheckoutErrorCodeDiscountExpired, CheckoutErrorCodeDiscountDisabled, CheckoutErrorCodeDiscountLimitReached, CheckoutErrorCodeDiscountNotFound, CheckoutErrorCodeCustomerAlreadyUsedOncePerCustomerDiscountNotice, CheckoutErrorCodeEmpty, CheckoutErrorCodeNotEnoughInStock, CheckoutErrorCodeMissingPaymentInput, CheckoutErrorCodeTotalPriceMismatch, CheckoutErrorCodeLineItemNotFound:
		return true
	}
	return false
}

func (e CheckoutErrorCode) String() string {
	return string(e)
}

func (e *CheckoutErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CheckoutErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CheckoutErrorCode", str)
	}
	return nil
}

func (e CheckoutErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the Collection query.
type CollectionSortKeys string

const (
	// Sort by the `title` value.
	CollectionSortKeysTitle CollectionSortKeys = "TITLE"
	// Sort by the `updated_at` value.
	CollectionSortKeysUpdatedAt CollectionSortKeys = "UPDATED_AT"
	// Sort by the `id` value.
	CollectionSortKeysID CollectionSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	CollectionSortKeysRelevance CollectionSortKeys = "RELEVANCE"
)

var AllCollectionSortKeys = []CollectionSortKeys{
	CollectionSortKeysTitle,
	CollectionSortKeysUpdatedAt,
	CollectionSortKeysID,
	CollectionSortKeysRelevance,
}

func (e CollectionSortKeys) IsValid() bool {
	switch e {
	case CollectionSortKeysTitle, CollectionSortKeysUpdatedAt, CollectionSortKeysID, CollectionSortKeysRelevance:
		return true
	}
	return false
}

func (e CollectionSortKeys) String() string {
	return string(e)
}

func (e *CollectionSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CollectionSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CollectionSortKeys", str)
	}
	return nil
}

func (e CollectionSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ISO 3166-1 alpha-2 country codes with some differences.
type CountryCode string

const (
	// Afghanistan.
	CountryCodeAf CountryCode = "AF"
	// Åland Islands.
	CountryCodeAx CountryCode = "AX"
	// Albania.
	CountryCodeAl CountryCode = "AL"
	// Algeria.
	CountryCodeDz CountryCode = "DZ"
	// Andorra.
	CountryCodeAd CountryCode = "AD"
	// Angola.
	CountryCodeAo CountryCode = "AO"
	// Anguilla.
	CountryCodeAi CountryCode = "AI"
	// Antigua & Barbuda.
	CountryCodeAg CountryCode = "AG"
	// Argentina.
	CountryCodeAr CountryCode = "AR"
	// Armenia.
	CountryCodeAm CountryCode = "AM"
	// Aruba.
	CountryCodeAw CountryCode = "AW"
	// Australia.
	CountryCodeAu CountryCode = "AU"
	// Austria.
	CountryCodeAt CountryCode = "AT"
	// Azerbaijan.
	CountryCodeAz CountryCode = "AZ"
	// Bahamas.
	CountryCodeBs CountryCode = "BS"
	// Bahrain.
	CountryCodeBh CountryCode = "BH"
	// Bangladesh.
	CountryCodeBd CountryCode = "BD"
	// Barbados.
	CountryCodeBb CountryCode = "BB"
	// Belarus.
	CountryCodeBy CountryCode = "BY"
	// Belgium.
	CountryCodeBe CountryCode = "BE"
	// Belize.
	CountryCodeBz CountryCode = "BZ"
	// Benin.
	CountryCodeBj CountryCode = "BJ"
	// Bermuda.
	CountryCodeBm CountryCode = "BM"
	// Bhutan.
	CountryCodeBt CountryCode = "BT"
	// Bolivia.
	CountryCodeBo CountryCode = "BO"
	// Bosnia & Herzegovina.
	CountryCodeBa CountryCode = "BA"
	// Botswana.
	CountryCodeBw CountryCode = "BW"
	// Bouvet Island.
	CountryCodeBv CountryCode = "BV"
	// Brazil.
	CountryCodeBr CountryCode = "BR"
	// British Indian Ocean Territory.
	CountryCodeIo CountryCode = "IO"
	// Brunei.
	CountryCodeBn CountryCode = "BN"
	// Bulgaria.
	CountryCodeBg CountryCode = "BG"
	// Burkina Faso.
	CountryCodeBf CountryCode = "BF"
	// Burundi.
	CountryCodeBi CountryCode = "BI"
	// Cambodia.
	CountryCodeKh CountryCode = "KH"
	// Canada.
	CountryCodeCa CountryCode = "CA"
	// Cape Verde.
	CountryCodeCv CountryCode = "CV"
	// Caribbean Netherlands.
	CountryCodeBq CountryCode = "BQ"
	// Cayman Islands.
	CountryCodeKy CountryCode = "KY"
	// Central African Republic.
	CountryCodeCf CountryCode = "CF"
	// Chad.
	CountryCodeTd CountryCode = "TD"
	// Chile.
	CountryCodeCl CountryCode = "CL"
	// China.
	CountryCodeCn CountryCode = "CN"
	// Christmas Island.
	CountryCodeCx CountryCode = "CX"
	// Cocos (Keeling) Islands.
	CountryCodeCc CountryCode = "CC"
	// Colombia.
	CountryCodeCo CountryCode = "CO"
	// Comoros.
	CountryCodeKm CountryCode = "KM"
	// Congo - Brazzaville.
	CountryCodeCg CountryCode = "CG"
	// Congo - Kinshasa.
	CountryCodeCd CountryCode = "CD"
	// Cook Islands.
	CountryCodeCk CountryCode = "CK"
	// Costa Rica.
	CountryCodeCr CountryCode = "CR"
	// Croatia.
	CountryCodeHr CountryCode = "HR"
	// Cuba.
	CountryCodeCu CountryCode = "CU"
	// Curaçao.
	CountryCodeCw CountryCode = "CW"
	// Cyprus.
	CountryCodeCy CountryCode = "CY"
	// Czechia.
	CountryCodeCz CountryCode = "CZ"
	// Côte d’Ivoire.
	CountryCodeCi CountryCode = "CI"
	// Denmark.
	CountryCodeDk CountryCode = "DK"
	// Djibouti.
	CountryCodeDj CountryCode = "DJ"
	// Dominica.
	CountryCodeDm CountryCode = "DM"
	// Dominican Republic.
	CountryCodeDo CountryCode = "DO"
	// Ecuador.
	CountryCodeEc CountryCode = "EC"
	// Egypt.
	CountryCodeEg CountryCode = "EG"
	// El Salvador.
	CountryCodeSv CountryCode = "SV"
	// Equatorial Guinea.
	CountryCodeGq CountryCode = "GQ"
	// Eritrea.
	CountryCodeEr CountryCode = "ER"
	// Estonia.
	CountryCodeEe CountryCode = "EE"
	// Eswatini.
	CountryCodeSz CountryCode = "SZ"
	// Ethiopia.
	CountryCodeEt CountryCode = "ET"
	// Falkland Islands.
	CountryCodeFk CountryCode = "FK"
	// Faroe Islands.
	CountryCodeFo CountryCode = "FO"
	// Fiji.
	CountryCodeFj CountryCode = "FJ"
	// Finland.
	CountryCodeFi CountryCode = "FI"
	// France.
	CountryCodeFr CountryCode = "FR"
	// French Guiana.
	CountryCodeGf CountryCode = "GF"
	// French Polynesia.
	CountryCodePf CountryCode = "PF"
	// French Southern Territories.
	CountryCodeTf CountryCode = "TF"
	// Gabon.
	CountryCodeGa CountryCode = "GA"
	// Gambia.
	CountryCodeGm CountryCode = "GM"
	// Georgia.
	CountryCodeGe CountryCode = "GE"
	// Germany.
	CountryCodeDe CountryCode = "DE"
	// Ghana.
	CountryCodeGh CountryCode = "GH"
	// Gibraltar.
	CountryCodeGi CountryCode = "GI"
	// Greece.
	CountryCodeGr CountryCode = "GR"
	// Greenland.
	CountryCodeGl CountryCode = "GL"
	// Grenada.
	CountryCodeGd CountryCode = "GD"
	// Guadeloupe.
	CountryCodeGp CountryCode = "GP"
	// Guatemala.
	CountryCodeGt CountryCode = "GT"
	// Guernsey.
	CountryCodeGg CountryCode = "GG"
	// Guinea.
	CountryCodeGn CountryCode = "GN"
	// Guinea-Bissau.
	CountryCodeGw CountryCode = "GW"
	// Guyana.
	CountryCodeGy CountryCode = "GY"
	// Haiti.
	CountryCodeHt CountryCode = "HT"
	// Heard & McDonald Islands.
	CountryCodeHm CountryCode = "HM"
	// Vatican City.
	CountryCodeVa CountryCode = "VA"
	// Honduras.
	CountryCodeHn CountryCode = "HN"
	// Hong Kong SAR.
	CountryCodeHk CountryCode = "HK"
	// Hungary.
	CountryCodeHu CountryCode = "HU"
	// Iceland.
	CountryCodeIs CountryCode = "IS"
	// India.
	CountryCodeIn CountryCode = "IN"
	// Indonesia.
	CountryCodeID CountryCode = "ID"
	// Iran.
	CountryCodeIr CountryCode = "IR"
	// Iraq.
	CountryCodeIq CountryCode = "IQ"
	// Ireland.
	CountryCodeIe CountryCode = "IE"
	// Isle of Man.
	CountryCodeIm CountryCode = "IM"
	// Israel.
	CountryCodeIl CountryCode = "IL"
	// Italy.
	CountryCodeIt CountryCode = "IT"
	// Jamaica.
	CountryCodeJm CountryCode = "JM"
	// Japan.
	CountryCodeJp CountryCode = "JP"
	// Jersey.
	CountryCodeJe CountryCode = "JE"
	// Jordan.
	CountryCodeJo CountryCode = "JO"
	// Kazakhstan.
	CountryCodeKz CountryCode = "KZ"
	// Kenya.
	CountryCodeKe CountryCode = "KE"
	// Kiribati.
	CountryCodeKi CountryCode = "KI"
	// North Korea.
	CountryCodeKp CountryCode = "KP"
	// Kosovo.
	CountryCodeXk CountryCode = "XK"
	// Kuwait.
	CountryCodeKw CountryCode = "KW"
	// Kyrgyzstan.
	CountryCodeKg CountryCode = "KG"
	// Laos.
	CountryCodeLa CountryCode = "LA"
	// Latvia.
	CountryCodeLv CountryCode = "LV"
	// Lebanon.
	CountryCodeLb CountryCode = "LB"
	// Lesotho.
	CountryCodeLs CountryCode = "LS"
	// Liberia.
	CountryCodeLr CountryCode = "LR"
	// Libya.
	CountryCodeLy CountryCode = "LY"
	// Liechtenstein.
	CountryCodeLi CountryCode = "LI"
	// Lithuania.
	CountryCodeLt CountryCode = "LT"
	// Luxembourg.
	CountryCodeLu CountryCode = "LU"
	// Macao SAR.
	CountryCodeMo CountryCode = "MO"
	// Madagascar.
	CountryCodeMg CountryCode = "MG"
	// Malawi.
	CountryCodeMw CountryCode = "MW"
	// Malaysia.
	CountryCodeMy CountryCode = "MY"
	// Maldives.
	CountryCodeMv CountryCode = "MV"
	// Mali.
	CountryCodeMl CountryCode = "ML"
	// Malta.
	CountryCodeMt CountryCode = "MT"
	// Martinique.
	CountryCodeMq CountryCode = "MQ"
	// Mauritania.
	CountryCodeMr CountryCode = "MR"
	// Mauritius.
	CountryCodeMu CountryCode = "MU"
	// Mayotte.
	CountryCodeYt CountryCode = "YT"
	// Mexico.
	CountryCodeMx CountryCode = "MX"
	// Moldova.
	CountryCodeMd CountryCode = "MD"
	// Monaco.
	CountryCodeMc CountryCode = "MC"
	// Mongolia.
	CountryCodeMn CountryCode = "MN"
	// Montenegro.
	CountryCodeMe CountryCode = "ME"
	// Montserrat.
	CountryCodeMs CountryCode = "MS"
	// Morocco.
	CountryCodeMa CountryCode = "MA"
	// Mozambique.
	CountryCodeMz CountryCode = "MZ"
	// Myanmar (Burma).
	CountryCodeMm CountryCode = "MM"
	// Namibia.
	CountryCodeNa CountryCode = "NA"
	// Nauru.
	CountryCodeNr CountryCode = "NR"
	// Nepal.
	CountryCodeNp CountryCode = "NP"
	// Netherlands.
	CountryCodeNl CountryCode = "NL"
	// Netherlands Antilles.
	CountryCodeAn CountryCode = "AN"
	// New Caledonia.
	CountryCodeNc CountryCode = "NC"
	// New Zealand.
	CountryCodeNz CountryCode = "NZ"
	// Nicaragua.
	CountryCodeNi CountryCode = "NI"
	// Niger.
	CountryCodeNe CountryCode = "NE"
	// Nigeria.
	CountryCodeNg CountryCode = "NG"
	// Niue.
	CountryCodeNu CountryCode = "NU"
	// Norfolk Island.
	CountryCodeNf CountryCode = "NF"
	// North Macedonia.
	CountryCodeMk CountryCode = "MK"
	// Norway.
	CountryCodeNo CountryCode = "NO"
	// Oman.
	CountryCodeOm CountryCode = "OM"
	// Pakistan.
	CountryCodePk CountryCode = "PK"
	// Palestinian Territories.
	CountryCodePs CountryCode = "PS"
	// Panama.
	CountryCodePa CountryCode = "PA"
	// Papua New Guinea.
	CountryCodePg CountryCode = "PG"
	// Paraguay.
	CountryCodePy CountryCode = "PY"
	// Peru.
	CountryCodePe CountryCode = "PE"
	// Philippines.
	CountryCodePh CountryCode = "PH"
	// Pitcairn Islands.
	CountryCodePn CountryCode = "PN"
	// Poland.
	CountryCodePl CountryCode = "PL"
	// Portugal.
	CountryCodePt CountryCode = "PT"
	// Qatar.
	CountryCodeQa CountryCode = "QA"
	// Cameroon.
	CountryCodeCm CountryCode = "CM"
	// Réunion.
	CountryCodeRe CountryCode = "RE"
	// Romania.
	CountryCodeRo CountryCode = "RO"
	// Russia.
	CountryCodeRu CountryCode = "RU"
	// Rwanda.
	CountryCodeRw CountryCode = "RW"
	// St. Barthélemy.
	CountryCodeBl CountryCode = "BL"
	// St. Helena.
	CountryCodeSh CountryCode = "SH"
	// St. Kitts & Nevis.
	CountryCodeKn CountryCode = "KN"
	// St. Lucia.
	CountryCodeLc CountryCode = "LC"
	// St. Martin.
	CountryCodeMf CountryCode = "MF"
	// St. Pierre & Miquelon.
	CountryCodePm CountryCode = "PM"
	// Samoa.
	CountryCodeWs CountryCode = "WS"
	// San Marino.
	CountryCodeSm CountryCode = "SM"
	// São Tomé & Príncipe.
	CountryCodeSt CountryCode = "ST"
	// Saudi Arabia.
	CountryCodeSa CountryCode = "SA"
	// Senegal.
	CountryCodeSn CountryCode = "SN"
	// Serbia.
	CountryCodeRs CountryCode = "RS"
	// Seychelles.
	CountryCodeSc CountryCode = "SC"
	// Sierra Leone.
	CountryCodeSl CountryCode = "SL"
	// Singapore.
	CountryCodeSg CountryCode = "SG"
	// Sint Maarten.
	CountryCodeSx CountryCode = "SX"
	// Slovakia.
	CountryCodeSk CountryCode = "SK"
	// Slovenia.
	CountryCodeSi CountryCode = "SI"
	// Solomon Islands.
	CountryCodeSb CountryCode = "SB"
	// Somalia.
	CountryCodeSo CountryCode = "SO"
	// South Africa.
	CountryCodeZa CountryCode = "ZA"
	// South Georgia & South Sandwich Islands.
	CountryCodeGs CountryCode = "GS"
	// South Korea.
	CountryCodeKr CountryCode = "KR"
	// South Sudan.
	CountryCodeSs CountryCode = "SS"
	// Spain.
	CountryCodeEs CountryCode = "ES"
	// Sri Lanka.
	CountryCodeLk CountryCode = "LK"
	// St. Vincent & Grenadines.
	CountryCodeVc CountryCode = "VC"
	// Sudan.
	CountryCodeSd CountryCode = "SD"
	// Suriname.
	CountryCodeSr CountryCode = "SR"
	// Svalbard & Jan Mayen.
	CountryCodeSj CountryCode = "SJ"
	// Sweden.
	CountryCodeSe CountryCode = "SE"
	// Switzerland.
	CountryCodeCh CountryCode = "CH"
	// Syria.
	CountryCodeSy CountryCode = "SY"
	// Taiwan.
	CountryCodeTw CountryCode = "TW"
	// Tajikistan.
	CountryCodeTj CountryCode = "TJ"
	// Tanzania.
	CountryCodeTz CountryCode = "TZ"
	// Thailand.
	CountryCodeTh CountryCode = "TH"
	// Timor-Leste.
	CountryCodeTl CountryCode = "TL"
	// Togo.
	CountryCodeTg CountryCode = "TG"
	// Tokelau.
	CountryCodeTk CountryCode = "TK"
	// Tonga.
	CountryCodeTo CountryCode = "TO"
	// Trinidad & Tobago.
	CountryCodeTt CountryCode = "TT"
	// Tunisia.
	CountryCodeTn CountryCode = "TN"
	// Turkey.
	CountryCodeTr CountryCode = "TR"
	// Turkmenistan.
	CountryCodeTm CountryCode = "TM"
	// Turks & Caicos Islands.
	CountryCodeTc CountryCode = "TC"
	// Tuvalu.
	CountryCodeTv CountryCode = "TV"
	// Uganda.
	CountryCodeUg CountryCode = "UG"
	// Ukraine.
	CountryCodeUa CountryCode = "UA"
	// United Arab Emirates.
	CountryCodeAe CountryCode = "AE"
	// United Kingdom.
	CountryCodeGb CountryCode = "GB"
	// United States.
	CountryCodeUs CountryCode = "US"
	// U.S. Outlying Islands.
	CountryCodeUm CountryCode = "UM"
	// Uruguay.
	CountryCodeUy CountryCode = "UY"
	// Uzbekistan.
	CountryCodeUz CountryCode = "UZ"
	// Vanuatu.
	CountryCodeVu CountryCode = "VU"
	// Venezuela.
	CountryCodeVe CountryCode = "VE"
	// Vietnam.
	CountryCodeVn CountryCode = "VN"
	// British Virgin Islands.
	CountryCodeVg CountryCode = "VG"
	// Wallis & Futuna.
	CountryCodeWf CountryCode = "WF"
	// Western Sahara.
	CountryCodeEh CountryCode = "EH"
	// Yemen.
	CountryCodeYe CountryCode = "YE"
	// Zambia.
	CountryCodeZm CountryCode = "ZM"
	// Zimbabwe.
	CountryCodeZw CountryCode = "ZW"
)

var AllCountryCode = []CountryCode{
	CountryCodeAf,
	CountryCodeAx,
	CountryCodeAl,
	CountryCodeDz,
	CountryCodeAd,
	CountryCodeAo,
	CountryCodeAi,
	CountryCodeAg,
	CountryCodeAr,
	CountryCodeAm,
	CountryCodeAw,
	CountryCodeAu,
	CountryCodeAt,
	CountryCodeAz,
	CountryCodeBs,
	CountryCodeBh,
	CountryCodeBd,
	CountryCodeBb,
	CountryCodeBy,
	CountryCodeBe,
	CountryCodeBz,
	CountryCodeBj,
	CountryCodeBm,
	CountryCodeBt,
	CountryCodeBo,
	CountryCodeBa,
	CountryCodeBw,
	CountryCodeBv,
	CountryCodeBr,
	CountryCodeIo,
	CountryCodeBn,
	CountryCodeBg,
	CountryCodeBf,
	CountryCodeBi,
	CountryCodeKh,
	CountryCodeCa,
	CountryCodeCv,
	CountryCodeBq,
	CountryCodeKy,
	CountryCodeCf,
	CountryCodeTd,
	CountryCodeCl,
	CountryCodeCn,
	CountryCodeCx,
	CountryCodeCc,
	CountryCodeCo,
	CountryCodeKm,
	CountryCodeCg,
	CountryCodeCd,
	CountryCodeCk,
	CountryCodeCr,
	CountryCodeHr,
	CountryCodeCu,
	CountryCodeCw,
	CountryCodeCy,
	CountryCodeCz,
	CountryCodeCi,
	CountryCodeDk,
	CountryCodeDj,
	CountryCodeDm,
	CountryCodeDo,
	CountryCodeEc,
	CountryCodeEg,
	CountryCodeSv,
	CountryCodeGq,
	CountryCodeEr,
	CountryCodeEe,
	CountryCodeSz,
	CountryCodeEt,
	CountryCodeFk,
	CountryCodeFo,
	CountryCodeFj,
	CountryCodeFi,
	CountryCodeFr,
	CountryCodeGf,
	CountryCodePf,
	CountryCodeTf,
	CountryCodeGa,
	CountryCodeGm,
	CountryCodeGe,
	CountryCodeDe,
	CountryCodeGh,
	CountryCodeGi,
	CountryCodeGr,
	CountryCodeGl,
	CountryCodeGd,
	CountryCodeGp,
	CountryCodeGt,
	CountryCodeGg,
	CountryCodeGn,
	CountryCodeGw,
	CountryCodeGy,
	CountryCodeHt,
	CountryCodeHm,
	CountryCodeVa,
	CountryCodeHn,
	CountryCodeHk,
	CountryCodeHu,
	CountryCodeIs,
	CountryCodeIn,
	CountryCodeID,
	CountryCodeIr,
	CountryCodeIq,
	CountryCodeIe,
	CountryCodeIm,
	CountryCodeIl,
	CountryCodeIt,
	CountryCodeJm,
	CountryCodeJp,
	CountryCodeJe,
	CountryCodeJo,
	CountryCodeKz,
	CountryCodeKe,
	CountryCodeKi,
	CountryCodeKp,
	CountryCodeXk,
	CountryCodeKw,
	CountryCodeKg,
	CountryCodeLa,
	CountryCodeLv,
	CountryCodeLb,
	CountryCodeLs,
	CountryCodeLr,
	CountryCodeLy,
	CountryCodeLi,
	CountryCodeLt,
	CountryCodeLu,
	CountryCodeMo,
	CountryCodeMg,
	CountryCodeMw,
	CountryCodeMy,
	CountryCodeMv,
	CountryCodeMl,
	CountryCodeMt,
	CountryCodeMq,
	CountryCodeMr,
	CountryCodeMu,
	CountryCodeYt,
	CountryCodeMx,
	CountryCodeMd,
	CountryCodeMc,
	CountryCodeMn,
	CountryCodeMe,
	CountryCodeMs,
	CountryCodeMa,
	CountryCodeMz,
	CountryCodeMm,
	CountryCodeNa,
	CountryCodeNr,
	CountryCodeNp,
	CountryCodeNl,
	CountryCodeAn,
	CountryCodeNc,
	CountryCodeNz,
	CountryCodeNi,
	CountryCodeNe,
	CountryCodeNg,
	CountryCodeNu,
	CountryCodeNf,
	CountryCodeMk,
	CountryCodeNo,
	CountryCodeOm,
	CountryCodePk,
	CountryCodePs,
	CountryCodePa,
	CountryCodePg,
	CountryCodePy,
	CountryCodePe,
	CountryCodePh,
	CountryCodePn,
	CountryCodePl,
	CountryCodePt,
	CountryCodeQa,
	CountryCodeCm,
	CountryCodeRe,
	CountryCodeRo,
	CountryCodeRu,
	CountryCodeRw,
	CountryCodeBl,
	CountryCodeSh,
	CountryCodeKn,
	CountryCodeLc,
	CountryCodeMf,
	CountryCodePm,
	CountryCodeWs,
	CountryCodeSm,
	CountryCodeSt,
	CountryCodeSa,
	CountryCodeSn,
	CountryCodeRs,
	CountryCodeSc,
	CountryCodeSl,
	CountryCodeSg,
	CountryCodeSx,
	CountryCodeSk,
	CountryCodeSi,
	CountryCodeSb,
	CountryCodeSo,
	CountryCodeZa,
	CountryCodeGs,
	CountryCodeKr,
	CountryCodeSs,
	CountryCodeEs,
	CountryCodeLk,
	CountryCodeVc,
	CountryCodeSd,
	CountryCodeSr,
	CountryCodeSj,
	CountryCodeSe,
	CountryCodeCh,
	CountryCodeSy,
	CountryCodeTw,
	CountryCodeTj,
	CountryCodeTz,
	CountryCodeTh,
	CountryCodeTl,
	CountryCodeTg,
	CountryCodeTk,
	CountryCodeTo,
	CountryCodeTt,
	CountryCodeTn,
	CountryCodeTr,
	CountryCodeTm,
	CountryCodeTc,
	CountryCodeTv,
	CountryCodeUg,
	CountryCodeUa,
	CountryCodeAe,
	CountryCodeGb,
	CountryCodeUs,
	CountryCodeUm,
	CountryCodeUy,
	CountryCodeUz,
	CountryCodeVu,
	CountryCodeVe,
	CountryCodeVn,
	CountryCodeVg,
	CountryCodeWf,
	CountryCodeEh,
	CountryCodeYe,
	CountryCodeZm,
	CountryCodeZw,
}

func (e CountryCode) IsValid() bool {
	switch e {
	case CountryCodeAf, CountryCodeAx, CountryCodeAl, CountryCodeDz, CountryCodeAd, CountryCodeAo, CountryCodeAi, CountryCodeAg, CountryCodeAr, CountryCodeAm, CountryCodeAw, CountryCodeAu, CountryCodeAt, CountryCodeAz, CountryCodeBs, CountryCodeBh, CountryCodeBd, CountryCodeBb, CountryCodeBy, CountryCodeBe, CountryCodeBz, CountryCodeBj, CountryCodeBm, CountryCodeBt, CountryCodeBo, CountryCodeBa, CountryCodeBw, CountryCodeBv, CountryCodeBr, CountryCodeIo, CountryCodeBn, CountryCodeBg, CountryCodeBf, CountryCodeBi, CountryCodeKh, CountryCodeCa, CountryCodeCv, CountryCodeBq, CountryCodeKy, CountryCodeCf, CountryCodeTd, CountryCodeCl, CountryCodeCn, CountryCodeCx, CountryCodeCc, CountryCodeCo, CountryCodeKm, CountryCodeCg, CountryCodeCd, CountryCodeCk, CountryCodeCr, CountryCodeHr, CountryCodeCu, CountryCodeCw, CountryCodeCy, CountryCodeCz, CountryCodeCi, CountryCodeDk, CountryCodeDj, CountryCodeDm, CountryCodeDo, CountryCodeEc, CountryCodeEg, CountryCodeSv, CountryCodeGq, CountryCodeEr, CountryCodeEe, CountryCodeSz, CountryCodeEt, CountryCodeFk, CountryCodeFo, CountryCodeFj, CountryCodeFi, CountryCodeFr, CountryCodeGf, CountryCodePf, CountryCodeTf, CountryCodeGa, CountryCodeGm, CountryCodeGe, CountryCodeDe, CountryCodeGh, CountryCodeGi, CountryCodeGr, CountryCodeGl, CountryCodeGd, CountryCodeGp, CountryCodeGt, CountryCodeGg, CountryCodeGn, CountryCodeGw, CountryCodeGy, CountryCodeHt, CountryCodeHm, CountryCodeVa, CountryCodeHn, CountryCodeHk, CountryCodeHu, CountryCodeIs, CountryCodeIn, CountryCodeID, CountryCodeIr, CountryCodeIq, CountryCodeIe, CountryCodeIm, CountryCodeIl, CountryCodeIt, CountryCodeJm, CountryCodeJp, CountryCodeJe, CountryCodeJo, CountryCodeKz, CountryCodeKe, CountryCodeKi, CountryCodeKp, CountryCodeXk, CountryCodeKw, CountryCodeKg, CountryCodeLa, CountryCodeLv, CountryCodeLb, CountryCodeLs, CountryCodeLr, CountryCodeLy, CountryCodeLi, CountryCodeLt, CountryCodeLu, CountryCodeMo, CountryCodeMg, CountryCodeMw, CountryCodeMy, CountryCodeMv, CountryCodeMl, CountryCodeMt, CountryCodeMq, CountryCodeMr, CountryCodeMu, CountryCodeYt, CountryCodeMx, CountryCodeMd, CountryCodeMc, CountryCodeMn, CountryCodeMe, CountryCodeMs, CountryCodeMa, CountryCodeMz, CountryCodeMm, CountryCodeNa, CountryCodeNr, CountryCodeNp, CountryCodeNl, CountryCodeAn, CountryCodeNc, CountryCodeNz, CountryCodeNi, CountryCodeNe, CountryCodeNg, CountryCodeNu, CountryCodeNf, CountryCodeMk, CountryCodeNo, CountryCodeOm, CountryCodePk, CountryCodePs, CountryCodePa, CountryCodePg, CountryCodePy, CountryCodePe, CountryCodePh, CountryCodePn, CountryCodePl, CountryCodePt, CountryCodeQa, CountryCodeCm, CountryCodeRe, CountryCodeRo, CountryCodeRu, CountryCodeRw, CountryCodeBl, CountryCodeSh, CountryCodeKn, CountryCodeLc, CountryCodeMf, CountryCodePm, CountryCodeWs, CountryCodeSm, CountryCodeSt, CountryCodeSa, CountryCodeSn, CountryCodeRs, CountryCodeSc, CountryCodeSl, CountryCodeSg, CountryCodeSx, CountryCodeSk, CountryCodeSi, CountryCodeSb, CountryCodeSo, CountryCodeZa, CountryCodeGs, CountryCodeKr, CountryCodeSs, CountryCodeEs, CountryCodeLk, CountryCodeVc, CountryCodeSd, CountryCodeSr, CountryCodeSj, CountryCodeSe, CountryCodeCh, CountryCodeSy, CountryCodeTw, CountryCodeTj, CountryCodeTz, CountryCodeTh, CountryCodeTl, CountryCodeTg, CountryCodeTk, CountryCodeTo, CountryCodeTt, CountryCodeTn, CountryCodeTr, CountryCodeTm, CountryCodeTc, CountryCodeTv, CountryCodeUg, CountryCodeUa, CountryCodeAe, CountryCodeGb, CountryCodeUs, CountryCodeUm, CountryCodeUy, CountryCodeUz, CountryCodeVu, CountryCodeVe, CountryCodeVn, CountryCodeVg, CountryCodeWf, CountryCodeEh, CountryCodeYe, CountryCodeZm, CountryCodeZw:
		return true
	}
	return false
}

func (e CountryCode) String() string {
	return string(e)
}

func (e *CountryCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CountryCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CountryCode", str)
	}
	return nil
}

func (e CountryCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The part of the image that should remain after cropping.
type CropRegion string

const (
	// Keep the center of the image.
	CropRegionCenter CropRegion = "CENTER"
	// Keep the top of the image.
	CropRegionTop CropRegion = "TOP"
	// Keep the bottom of the image.
	CropRegionBottom CropRegion = "BOTTOM"
	// Keep the left of the image.
	CropRegionLeft CropRegion = "LEFT"
	// Keep the right of the image.
	CropRegionRight CropRegion = "RIGHT"
)

var AllCropRegion = []CropRegion{
	CropRegionCenter,
	CropRegionTop,
	CropRegionBottom,
	CropRegionLeft,
	CropRegionRight,
}

func (e CropRegion) IsValid() bool {
	switch e {
	case CropRegionCenter, CropRegionTop, CropRegionBottom, CropRegionLeft, CropRegionRight:
		return true
	}
	return false
}

func (e CropRegion) String() string {
	return string(e)
}

func (e *CropRegion) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CropRegion(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CropRegion", str)
	}
	return nil
}

func (e CropRegion) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Currency codes.
type CurrencyCode string

const (
	// United States Dollars (USD).
	CurrencyCodeUsd CurrencyCode = "USD"
	// Euro (EUR).
	CurrencyCodeEur CurrencyCode = "EUR"
	// United Kingdom Pounds (GBP).
	CurrencyCodeGbp CurrencyCode = "GBP"
	// Canadian Dollars (CAD).
	CurrencyCodeCad CurrencyCode = "CAD"
	// Afghan Afghani (AFN).
	CurrencyCodeAfn CurrencyCode = "AFN"
	// Albanian Lek (ALL).
	CurrencyCodeAll CurrencyCode = "ALL"
	// Algerian Dinar (DZD).
	CurrencyCodeDzd CurrencyCode = "DZD"
	// Angolan Kwanza (AOA).
	CurrencyCodeAoa CurrencyCode = "AOA"
	// Argentine Pesos (ARS).
	CurrencyCodeArs CurrencyCode = "ARS"
	// Armenian Dram (AMD).
	CurrencyCodeAmd CurrencyCode = "AMD"
	// Aruban Florin (AWG).
	CurrencyCodeAwg CurrencyCode = "AWG"
	// Australian Dollars (AUD).
	CurrencyCodeAud CurrencyCode = "AUD"
	// Barbadian Dollar (BBD).
	CurrencyCodeBbd CurrencyCode = "BBD"
	// Azerbaijani Manat (AZN).
	CurrencyCodeAzn CurrencyCode = "AZN"
	// Bangladesh Taka (BDT).
	CurrencyCodeBdt CurrencyCode = "BDT"
	// Bahamian Dollar (BSD).
	CurrencyCodeBsd CurrencyCode = "BSD"
	// Bahraini Dinar (BHD).
	CurrencyCodeBhd CurrencyCode = "BHD"
	// Burundian Franc (BIF).
	CurrencyCodeBif CurrencyCode = "BIF"
	// Belize Dollar (BZD).
	CurrencyCodeBzd CurrencyCode = "BZD"
	// Bermudian Dollar (BMD).
	CurrencyCodeBmd CurrencyCode = "BMD"
	// Bhutanese Ngultrum (BTN).
	CurrencyCodeBtn CurrencyCode = "BTN"
	// Bosnia and Herzegovina Convertible Mark (BAM).
	CurrencyCodeBam CurrencyCode = "BAM"
	// Brazilian Real (BRL).
	CurrencyCodeBrl CurrencyCode = "BRL"
	// Bolivian Boliviano (BOB).
	CurrencyCodeBob CurrencyCode = "BOB"
	// Botswana Pula (BWP).
	CurrencyCodeBwp CurrencyCode = "BWP"
	// Brunei Dollar (BND).
	CurrencyCodeBnd CurrencyCode = "BND"
	// Bulgarian Lev (BGN).
	CurrencyCodeBgn CurrencyCode = "BGN"
	// Burmese Kyat (MMK).
	CurrencyCodeMmk CurrencyCode = "MMK"
	// Cambodian Riel.
	CurrencyCodeKhr CurrencyCode = "KHR"
	// Cape Verdean escudo (CVE).
	CurrencyCodeCve CurrencyCode = "CVE"
	// Cayman Dollars (KYD).
	CurrencyCodeKyd CurrencyCode = "KYD"
	// Central African CFA Franc (XAF).
	CurrencyCodeXaf CurrencyCode = "XAF"
	// Chilean Peso (CLP).
	CurrencyCodeClp CurrencyCode = "CLP"
	// Chinese Yuan Renminbi (CNY).
	CurrencyCodeCny CurrencyCode = "CNY"
	// Colombian Peso (COP).
	CurrencyCodeCop CurrencyCode = "COP"
	// Comorian Franc (KMF).
	CurrencyCodeKmf CurrencyCode = "KMF"
	// Congolese franc (CDF).
	CurrencyCodeCdf CurrencyCode = "CDF"
	// Costa Rican Colones (CRC).
	CurrencyCodeCrc CurrencyCode = "CRC"
	// Croatian Kuna (HRK).
	CurrencyCodeHrk CurrencyCode = "HRK"
	// Czech Koruny (CZK).
	CurrencyCodeCzk CurrencyCode = "CZK"
	// Danish Kroner (DKK).
	CurrencyCodeDkk CurrencyCode = "DKK"
	// Dominican Peso (DOP).
	CurrencyCodeDop CurrencyCode = "DOP"
	// East Caribbean Dollar (XCD).
	CurrencyCodeXcd CurrencyCode = "XCD"
	// Egyptian Pound (EGP).
	CurrencyCodeEgp CurrencyCode = "EGP"
	// Ethiopian Birr (ETB).
	CurrencyCodeEtb CurrencyCode = "ETB"
	// CFP Franc (XPF).
	CurrencyCodeXpf CurrencyCode = "XPF"
	// Fijian Dollars (FJD).
	CurrencyCodeFjd CurrencyCode = "FJD"
	// Gambian Dalasi (GMD).
	CurrencyCodeGmd CurrencyCode = "GMD"
	// Ghanaian Cedi (GHS).
	CurrencyCodeGhs CurrencyCode = "GHS"
	// Guatemalan Quetzal (GTQ).
	CurrencyCodeGtq CurrencyCode = "GTQ"
	// Guyanese Dollar (GYD).
	CurrencyCodeGyd CurrencyCode = "GYD"
	// Georgian Lari (GEL).
	CurrencyCodeGel CurrencyCode = "GEL"
	// Haitian Gourde (HTG).
	CurrencyCodeHtg CurrencyCode = "HTG"
	// Honduran Lempira (HNL).
	CurrencyCodeHnl CurrencyCode = "HNL"
	// Hong Kong Dollars (HKD).
	CurrencyCodeHkd CurrencyCode = "HKD"
	// Hungarian Forint (HUF).
	CurrencyCodeHuf CurrencyCode = "HUF"
	// Icelandic Kronur (ISK).
	CurrencyCodeIsk CurrencyCode = "ISK"
	// Indian Rupees (INR).
	CurrencyCodeInr CurrencyCode = "INR"
	// Indonesian Rupiah (IDR).
	CurrencyCodeIDR CurrencyCode = "IDR"
	// Israeli New Shekel (NIS).
	CurrencyCodeIls CurrencyCode = "ILS"
	// Iraqi Dinar (IQD).
	CurrencyCodeIqd CurrencyCode = "IQD"
	// Jamaican Dollars (JMD).
	CurrencyCodeJmd CurrencyCode = "JMD"
	// Japanese Yen (JPY).
	CurrencyCodeJpy CurrencyCode = "JPY"
	// Jersey Pound.
	CurrencyCodeJep CurrencyCode = "JEP"
	// Jordanian Dinar (JOD).
	CurrencyCodeJod CurrencyCode = "JOD"
	// Kazakhstani Tenge (KZT).
	CurrencyCodeKzt CurrencyCode = "KZT"
	// Kenyan Shilling (KES).
	CurrencyCodeKes CurrencyCode = "KES"
	// Kuwaiti Dinar (KWD).
	CurrencyCodeKwd CurrencyCode = "KWD"
	// Kyrgyzstani Som (KGS).
	CurrencyCodeKgs CurrencyCode = "KGS"
	// Laotian Kip (LAK).
	CurrencyCodeLak CurrencyCode = "LAK"
	// Latvian Lati (LVL).
	CurrencyCodeLvl CurrencyCode = "LVL"
	// Lebanese Pounds (LBP).
	CurrencyCodeLbp CurrencyCode = "LBP"
	// Lesotho Loti (LSL).
	CurrencyCodeLsl CurrencyCode = "LSL"
	// Liberian Dollar (LRD).
	CurrencyCodeLrd CurrencyCode = "LRD"
	// Lithuanian Litai (LTL).
	CurrencyCodeLtl CurrencyCode = "LTL"
	// Malagasy Ariary (MGA).
	CurrencyCodeMga CurrencyCode = "MGA"
	// Macedonia Denar (MKD).
	CurrencyCodeMkd CurrencyCode = "MKD"
	// Macanese Pataca (MOP).
	CurrencyCodeMop CurrencyCode = "MOP"
	// Malawian Kwacha (MWK).
	CurrencyCodeMwk CurrencyCode = "MWK"
	// Maldivian Rufiyaa (MVR).
	CurrencyCodeMvr CurrencyCode = "MVR"
	// Mexican Pesos (MXN).
	CurrencyCodeMxn CurrencyCode = "MXN"
	// Malaysian Ringgits (MYR).
	CurrencyCodeMyr CurrencyCode = "MYR"
	// Mauritian Rupee (MUR).
	CurrencyCodeMur CurrencyCode = "MUR"
	// Moldovan Leu (MDL).
	CurrencyCodeMdl CurrencyCode = "MDL"
	// Moroccan Dirham.
	CurrencyCodeMad CurrencyCode = "MAD"
	// Mongolian Tugrik.
	CurrencyCodeMnt CurrencyCode = "MNT"
	// Mozambican Metical.
	CurrencyCodeMzn CurrencyCode = "MZN"
	// Namibian Dollar.
	CurrencyCodeNad CurrencyCode = "NAD"
	// Nepalese Rupee (NPR).
	CurrencyCodeNpr CurrencyCode = "NPR"
	// Netherlands Antillean Guilder.
	CurrencyCodeAng CurrencyCode = "ANG"
	// New Zealand Dollars (NZD).
	CurrencyCodeNzd CurrencyCode = "NZD"
	// Nicaraguan Córdoba (NIO).
	CurrencyCodeNio CurrencyCode = "NIO"
	// Nigerian Naira (NGN).
	CurrencyCodeNgn CurrencyCode = "NGN"
	// Norwegian Kroner (NOK).
	CurrencyCodeNok CurrencyCode = "NOK"
	// Omani Rial (OMR).
	CurrencyCodeOmr CurrencyCode = "OMR"
	// Panamian Balboa (PAB).
	CurrencyCodePab CurrencyCode = "PAB"
	// Pakistani Rupee (PKR).
	CurrencyCodePkr CurrencyCode = "PKR"
	// Papua New Guinean Kina (PGK).
	CurrencyCodePgk CurrencyCode = "PGK"
	// Paraguayan Guarani (PYG).
	CurrencyCodePyg CurrencyCode = "PYG"
	// Peruvian Nuevo Sol (PEN).
	CurrencyCodePen CurrencyCode = "PEN"
	// Philippine Peso (PHP).
	CurrencyCodePhp CurrencyCode = "PHP"
	// Polish Zlotych (PLN).
	CurrencyCodePln CurrencyCode = "PLN"
	// Qatari Rial (QAR).
	CurrencyCodeQar CurrencyCode = "QAR"
	// Romanian Lei (RON).
	CurrencyCodeRon CurrencyCode = "RON"
	// Russian Rubles (RUB).
	CurrencyCodeRub CurrencyCode = "RUB"
	// Rwandan Franc (RWF).
	CurrencyCodeRwf CurrencyCode = "RWF"
	// Samoan Tala (WST).
	CurrencyCodeWst CurrencyCode = "WST"
	// Saudi Riyal (SAR).
	CurrencyCodeSar CurrencyCode = "SAR"
	// Sao Tome And Principe Dobra (STD).
	CurrencyCodeStd CurrencyCode = "STD"
	// Serbian dinar (RSD).
	CurrencyCodeRsd CurrencyCode = "RSD"
	// Seychellois Rupee (SCR).
	CurrencyCodeScr CurrencyCode = "SCR"
	// Singapore Dollars (SGD).
	CurrencyCodeSgd CurrencyCode = "SGD"
	// Sudanese Pound (SDG).
	CurrencyCodeSdg CurrencyCode = "SDG"
	// Syrian Pound (SYP).
	CurrencyCodeSyp CurrencyCode = "SYP"
	// South African Rand (ZAR).
	CurrencyCodeZar CurrencyCode = "ZAR"
	// South Korean Won (KRW).
	CurrencyCodeKrw CurrencyCode = "KRW"
	// South Sudanese Pound (SSP).
	CurrencyCodeSsp CurrencyCode = "SSP"
	// Solomon Islands Dollar (SBD).
	CurrencyCodeSbd CurrencyCode = "SBD"
	// Sri Lankan Rupees (LKR).
	CurrencyCodeLkr CurrencyCode = "LKR"
	// Surinamese Dollar (SRD).
	CurrencyCodeSrd CurrencyCode = "SRD"
	// Swazi Lilangeni (SZL).
	CurrencyCodeSzl CurrencyCode = "SZL"
	// Swedish Kronor (SEK).
	CurrencyCodeSek CurrencyCode = "SEK"
	// Swiss Francs (CHF).
	CurrencyCodeChf CurrencyCode = "CHF"
	// Taiwan Dollars (TWD).
	CurrencyCodeTwd CurrencyCode = "TWD"
	// Thai baht (THB).
	CurrencyCodeThb CurrencyCode = "THB"
	// Tanzanian Shilling (TZS).
	CurrencyCodeTzs CurrencyCode = "TZS"
	// Trinidad and Tobago Dollars (TTD).
	CurrencyCodeTtd CurrencyCode = "TTD"
	// Tunisian Dinar (TND).
	CurrencyCodeTnd CurrencyCode = "TND"
	// Turkish Lira (TRY).
	CurrencyCodeTry CurrencyCode = "TRY"
	// Turkmenistani Manat (TMT).
	CurrencyCodeTmt CurrencyCode = "TMT"
	// Ugandan Shilling (UGX).
	CurrencyCodeUgx CurrencyCode = "UGX"
	// Ukrainian Hryvnia (UAH).
	CurrencyCodeUah CurrencyCode = "UAH"
	// United Arab Emirates Dirham (AED).
	CurrencyCodeAed CurrencyCode = "AED"
	// Uruguayan Pesos (UYU).
	CurrencyCodeUyu CurrencyCode = "UYU"
	// Uzbekistan som (UZS).
	CurrencyCodeUzs CurrencyCode = "UZS"
	// Vanuatu Vatu (VUV).
	CurrencyCodeVuv CurrencyCode = "VUV"
	// Vietnamese đồng (VND).
	CurrencyCodeVnd CurrencyCode = "VND"
	// West African CFA franc (XOF).
	CurrencyCodeXof CurrencyCode = "XOF"
	// Yemeni Rial (YER).
	CurrencyCodeYer CurrencyCode = "YER"
	// Zambian Kwacha (ZMW).
	CurrencyCodeZmw CurrencyCode = "ZMW"
	// Belarusian Ruble (BYR).
	CurrencyCodeByr CurrencyCode = "BYR"
	// Venezuelan Bolivares (VEF).
	CurrencyCodeVef CurrencyCode = "VEF"
)

var AllCurrencyCode = []CurrencyCode{
	CurrencyCodeUsd,
	CurrencyCodeEur,
	CurrencyCodeGbp,
	CurrencyCodeCad,
	CurrencyCodeAfn,
	CurrencyCodeAll,
	CurrencyCodeDzd,
	CurrencyCodeAoa,
	CurrencyCodeArs,
	CurrencyCodeAmd,
	CurrencyCodeAwg,
	CurrencyCodeAud,
	CurrencyCodeBbd,
	CurrencyCodeAzn,
	CurrencyCodeBdt,
	CurrencyCodeBsd,
	CurrencyCodeBhd,
	CurrencyCodeBif,
	CurrencyCodeBzd,
	CurrencyCodeBmd,
	CurrencyCodeBtn,
	CurrencyCodeBam,
	CurrencyCodeBrl,
	CurrencyCodeBob,
	CurrencyCodeBwp,
	CurrencyCodeBnd,
	CurrencyCodeBgn,
	CurrencyCodeMmk,
	CurrencyCodeKhr,
	CurrencyCodeCve,
	CurrencyCodeKyd,
	CurrencyCodeXaf,
	CurrencyCodeClp,
	CurrencyCodeCny,
	CurrencyCodeCop,
	CurrencyCodeKmf,
	CurrencyCodeCdf,
	CurrencyCodeCrc,
	CurrencyCodeHrk,
	CurrencyCodeCzk,
	CurrencyCodeDkk,
	CurrencyCodeDop,
	CurrencyCodeXcd,
	CurrencyCodeEgp,
	CurrencyCodeEtb,
	CurrencyCodeXpf,
	CurrencyCodeFjd,
	CurrencyCodeGmd,
	CurrencyCodeGhs,
	CurrencyCodeGtq,
	CurrencyCodeGyd,
	CurrencyCodeGel,
	CurrencyCodeHtg,
	CurrencyCodeHnl,
	CurrencyCodeHkd,
	CurrencyCodeHuf,
	CurrencyCodeIsk,
	CurrencyCodeInr,
	CurrencyCodeIDR,
	CurrencyCodeIls,
	CurrencyCodeIqd,
	CurrencyCodeJmd,
	CurrencyCodeJpy,
	CurrencyCodeJep,
	CurrencyCodeJod,
	CurrencyCodeKzt,
	CurrencyCodeKes,
	CurrencyCodeKwd,
	CurrencyCodeKgs,
	CurrencyCodeLak,
	CurrencyCodeLvl,
	CurrencyCodeLbp,
	CurrencyCodeLsl,
	CurrencyCodeLrd,
	CurrencyCodeLtl,
	CurrencyCodeMga,
	CurrencyCodeMkd,
	CurrencyCodeMop,
	CurrencyCodeMwk,
	CurrencyCodeMvr,
	CurrencyCodeMxn,
	CurrencyCodeMyr,
	CurrencyCodeMur,
	CurrencyCodeMdl,
	CurrencyCodeMad,
	CurrencyCodeMnt,
	CurrencyCodeMzn,
	CurrencyCodeNad,
	CurrencyCodeNpr,
	CurrencyCodeAng,
	CurrencyCodeNzd,
	CurrencyCodeNio,
	CurrencyCodeNgn,
	CurrencyCodeNok,
	CurrencyCodeOmr,
	CurrencyCodePab,
	CurrencyCodePkr,
	CurrencyCodePgk,
	CurrencyCodePyg,
	CurrencyCodePen,
	CurrencyCodePhp,
	CurrencyCodePln,
	CurrencyCodeQar,
	CurrencyCodeRon,
	CurrencyCodeRub,
	CurrencyCodeRwf,
	CurrencyCodeWst,
	CurrencyCodeSar,
	CurrencyCodeStd,
	CurrencyCodeRsd,
	CurrencyCodeScr,
	CurrencyCodeSgd,
	CurrencyCodeSdg,
	CurrencyCodeSyp,
	CurrencyCodeZar,
	CurrencyCodeKrw,
	CurrencyCodeSsp,
	CurrencyCodeSbd,
	CurrencyCodeLkr,
	CurrencyCodeSrd,
	CurrencyCodeSzl,
	CurrencyCodeSek,
	CurrencyCodeChf,
	CurrencyCodeTwd,
	CurrencyCodeThb,
	CurrencyCodeTzs,
	CurrencyCodeTtd,
	CurrencyCodeTnd,
	CurrencyCodeTry,
	CurrencyCodeTmt,
	CurrencyCodeUgx,
	CurrencyCodeUah,
	CurrencyCodeAed,
	CurrencyCodeUyu,
	CurrencyCodeUzs,
	CurrencyCodeVuv,
	CurrencyCodeVnd,
	CurrencyCodeXof,
	CurrencyCodeYer,
	CurrencyCodeZmw,
	CurrencyCodeByr,
	CurrencyCodeVef,
}

func (e CurrencyCode) IsValid() bool {
	switch e {
	case CurrencyCodeUsd, CurrencyCodeEur, CurrencyCodeGbp, CurrencyCodeCad, CurrencyCodeAfn, CurrencyCodeAll, CurrencyCodeDzd, CurrencyCodeAoa, CurrencyCodeArs, CurrencyCodeAmd, CurrencyCodeAwg, CurrencyCodeAud, CurrencyCodeBbd, CurrencyCodeAzn, CurrencyCodeBdt, CurrencyCodeBsd, CurrencyCodeBhd, CurrencyCodeBif, CurrencyCodeBzd, CurrencyCodeBmd, CurrencyCodeBtn, CurrencyCodeBam, CurrencyCodeBrl, CurrencyCodeBob, CurrencyCodeBwp, CurrencyCodeBnd, CurrencyCodeBgn, CurrencyCodeMmk, CurrencyCodeKhr, CurrencyCodeCve, CurrencyCodeKyd, CurrencyCodeXaf, CurrencyCodeClp, CurrencyCodeCny, CurrencyCodeCop, CurrencyCodeKmf, CurrencyCodeCdf, CurrencyCodeCrc, CurrencyCodeHrk, CurrencyCodeCzk, CurrencyCodeDkk, CurrencyCodeDop, CurrencyCodeXcd, CurrencyCodeEgp, CurrencyCodeEtb, CurrencyCodeXpf, CurrencyCodeFjd, CurrencyCodeGmd, CurrencyCodeGhs, CurrencyCodeGtq, CurrencyCodeGyd, CurrencyCodeGel, CurrencyCodeHtg, CurrencyCodeHnl, CurrencyCodeHkd, CurrencyCodeHuf, CurrencyCodeIsk, CurrencyCodeInr, CurrencyCodeIDR, CurrencyCodeIls, CurrencyCodeIqd, CurrencyCodeJmd, CurrencyCodeJpy, CurrencyCodeJep, CurrencyCodeJod, CurrencyCodeKzt, CurrencyCodeKes, CurrencyCodeKwd, CurrencyCodeKgs, CurrencyCodeLak, CurrencyCodeLvl, CurrencyCodeLbp, CurrencyCodeLsl, CurrencyCodeLrd, CurrencyCodeLtl, CurrencyCodeMga, CurrencyCodeMkd, CurrencyCodeMop, CurrencyCodeMwk, CurrencyCodeMvr, CurrencyCodeMxn, CurrencyCodeMyr, CurrencyCodeMur, CurrencyCodeMdl, CurrencyCodeMad, CurrencyCodeMnt, CurrencyCodeMzn, CurrencyCodeNad, CurrencyCodeNpr, CurrencyCodeAng, CurrencyCodeNzd, CurrencyCodeNio, CurrencyCodeNgn, CurrencyCodeNok, CurrencyCodeOmr, CurrencyCodePab, CurrencyCodePkr, CurrencyCodePgk, CurrencyCodePyg, CurrencyCodePen, CurrencyCodePhp, CurrencyCodePln, CurrencyCodeQar, CurrencyCodeRon, CurrencyCodeRub, CurrencyCodeRwf, CurrencyCodeWst, CurrencyCodeSar, CurrencyCodeStd, CurrencyCodeRsd, CurrencyCodeScr, CurrencyCodeSgd, CurrencyCodeSdg, CurrencyCodeSyp, CurrencyCodeZar, CurrencyCodeKrw, CurrencyCodeSsp, CurrencyCodeSbd, CurrencyCodeLkr, CurrencyCodeSrd, CurrencyCodeSzl, CurrencyCodeSek, CurrencyCodeChf, CurrencyCodeTwd, CurrencyCodeThb, CurrencyCodeTzs, CurrencyCodeTtd, CurrencyCodeTnd, CurrencyCodeTry, CurrencyCodeTmt, CurrencyCodeUgx, CurrencyCodeUah, CurrencyCodeAed, CurrencyCodeUyu, CurrencyCodeUzs, CurrencyCodeVuv, CurrencyCodeVnd, CurrencyCodeXof, CurrencyCodeYer, CurrencyCodeZmw, CurrencyCodeByr, CurrencyCodeVef:
		return true
	}
	return false
}

func (e CurrencyCode) String() string {
	return string(e)
}

func (e *CurrencyCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CurrencyCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CurrencyCode", str)
	}
	return nil
}

func (e CurrencyCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes that could be returned by CustomerUserError.
type CustomerErrorCode string

const (
	// Input value is blank.
	CustomerErrorCodeBlank CustomerErrorCode = "BLANK"
	// Input value is invalid.
	CustomerErrorCodeInvalid CustomerErrorCode = "INVALID"
	// Input value is already taken.
	CustomerErrorCodeTaken CustomerErrorCode = "TAKEN"
	// Input value is too long.
	CustomerErrorCodeTooLong CustomerErrorCode = "TOO_LONG"
	// Input value is too short.
	CustomerErrorCodeTooShort CustomerErrorCode = "TOO_SHORT"
	// Unidentified customer.
	CustomerErrorCodeUnidentifiedCustomer CustomerErrorCode = "UNIDENTIFIED_CUSTOMER"
	// Customer is disabled.
	CustomerErrorCodeCustomerDisabled CustomerErrorCode = "CUSTOMER_DISABLED"
	// Input password starts or ends with whitespace.
	CustomerErrorCodePasswordStartsOrEndsWithWhitespace CustomerErrorCode = "PASSWORD_STARTS_OR_ENDS_WITH_WHITESPACE"
	// Input contains HTML tags.
	CustomerErrorCodeContainsHTMLTags CustomerErrorCode = "CONTAINS_HTML_TAGS"
	// Input contains URL.
	CustomerErrorCodeContainsURL CustomerErrorCode = "CONTAINS_URL"
	// Invalid activation token.
	CustomerErrorCodeTokenInvalid CustomerErrorCode = "TOKEN_INVALID"
	// Customer already enabled.
	CustomerErrorCodeAlreadyEnabled CustomerErrorCode = "ALREADY_ENABLED"
	// Address does not exist.
	CustomerErrorCodeNotFound CustomerErrorCode = "NOT_FOUND"
)

var AllCustomerErrorCode = []CustomerErrorCode{
	CustomerErrorCodeBlank,
	CustomerErrorCodeInvalid,
	CustomerErrorCodeTaken,
	CustomerErrorCodeTooLong,
	CustomerErrorCodeTooShort,
	CustomerErrorCodeUnidentifiedCustomer,
	CustomerErrorCodeCustomerDisabled,
	CustomerErrorCodePasswordStartsOrEndsWithWhitespace,
	CustomerErrorCodeContainsHTMLTags,
	CustomerErrorCodeContainsURL,
	CustomerErrorCodeTokenInvalid,
	CustomerErrorCodeAlreadyEnabled,
	CustomerErrorCodeNotFound,
}

func (e CustomerErrorCode) IsValid() bool {
	switch e {
	case CustomerErrorCodeBlank, CustomerErrorCodeInvalid, CustomerErrorCodeTaken, CustomerErrorCodeTooLong, CustomerErrorCodeTooShort, CustomerErrorCodeUnidentifiedCustomer, CustomerErrorCodeCustomerDisabled, CustomerErrorCodePasswordStartsOrEndsWithWhitespace, CustomerErrorCodeContainsHTMLTags, CustomerErrorCodeContainsURL, CustomerErrorCodeTokenInvalid, CustomerErrorCodeAlreadyEnabled, CustomerErrorCodeNotFound:
		return true
	}
	return false
}

func (e CustomerErrorCode) String() string {
	return string(e)
}

func (e *CustomerErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomerErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomerErrorCode", str)
	}
	return nil
}

func (e CustomerErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Digital wallet, such as Apple Pay, which can be used for accelerated checkouts.
type DigitalWallet string

const (
	// Apple Pay.
	DigitalWalletApplePay DigitalWallet = "APPLE_PAY"
	// Android Pay.
	DigitalWalletAndroidPay DigitalWallet = "ANDROID_PAY"
	// Google Pay.
	DigitalWalletGooglePay DigitalWallet = "GOOGLE_PAY"
	// Shopify Pay.
	DigitalWalletShopifyPay DigitalWallet = "SHOPIFY_PAY"
)

var AllDigitalWallet = []DigitalWallet{
	DigitalWalletApplePay,
	DigitalWalletAndroidPay,
	DigitalWalletGooglePay,
	DigitalWalletShopifyPay,
}

func (e DigitalWallet) IsValid() bool {
	switch e {
	case DigitalWalletApplePay, DigitalWalletAndroidPay, DigitalWalletGooglePay, DigitalWalletShopifyPay:
		return true
	}
	return false
}

func (e DigitalWallet) String() string {
	return string(e)
}

func (e *DigitalWallet) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DigitalWallet(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DigitalWallet", str)
	}
	return nil
}

func (e DigitalWallet) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The method by which the discount's value is allocated onto its entitled lines.
type DiscountApplicationAllocationMethod string

const (
	// The value is spread across all entitled lines.
	DiscountApplicationAllocationMethodAcross DiscountApplicationAllocationMethod = "ACROSS"
	// The value is applied onto every entitled line.
	DiscountApplicationAllocationMethodEach DiscountApplicationAllocationMethod = "EACH"
	// The value is specifically applied onto a particular line.
	DiscountApplicationAllocationMethodOne DiscountApplicationAllocationMethod = "ONE"
)

var AllDiscountApplicationAllocationMethod = []DiscountApplicationAllocationMethod{
	DiscountApplicationAllocationMethodAcross,
	DiscountApplicationAllocationMethodEach,
	DiscountApplicationAllocationMethodOne,
}

func (e DiscountApplicationAllocationMethod) IsValid() bool {
	switch e {
	case DiscountApplicationAllocationMethodAcross, DiscountApplicationAllocationMethodEach, DiscountApplicationAllocationMethodOne:
		return true
	}
	return false
}

func (e DiscountApplicationAllocationMethod) String() string {
	return string(e)
}

func (e *DiscountApplicationAllocationMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscountApplicationAllocationMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscountApplicationAllocationMethod", str)
	}
	return nil
}

func (e DiscountApplicationAllocationMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Which lines on the order that the discount is allocated over, of the type
// defined by the Discount Application's target_type.
type DiscountApplicationTargetSelection string

const (
	// The discount is allocated onto all the lines.
	DiscountApplicationTargetSelectionAll DiscountApplicationTargetSelection = "ALL"
	// The discount is allocated onto only the lines it is entitled for.
	DiscountApplicationTargetSelectionEntitled DiscountApplicationTargetSelection = "ENTITLED"
	// The discount is allocated onto explicitly chosen lines.
	DiscountApplicationTargetSelectionExplicit DiscountApplicationTargetSelection = "EXPLICIT"
)

var AllDiscountApplicationTargetSelection = []DiscountApplicationTargetSelection{
	DiscountApplicationTargetSelectionAll,
	DiscountApplicationTargetSelectionEntitled,
	DiscountApplicationTargetSelectionExplicit,
}

func (e DiscountApplicationTargetSelection) IsValid() bool {
	switch e {
	case DiscountApplicationTargetSelectionAll, DiscountApplicationTargetSelectionEntitled, DiscountApplicationTargetSelectionExplicit:
		return true
	}
	return false
}

func (e DiscountApplicationTargetSelection) String() string {
	return string(e)
}

func (e *DiscountApplicationTargetSelection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscountApplicationTargetSelection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscountApplicationTargetSelection", str)
	}
	return nil
}

func (e DiscountApplicationTargetSelection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of line (i.e. line item or shipping line) on an order that the discount is applicable towards.
type DiscountApplicationTargetType string

const (
	// The discount applies onto line items.
	DiscountApplicationTargetTypeLineItem DiscountApplicationTargetType = "LINE_ITEM"
	// The discount applies onto shipping lines.
	DiscountApplicationTargetTypeShippingLine DiscountApplicationTargetType = "SHIPPING_LINE"
)

var AllDiscountApplicationTargetType = []DiscountApplicationTargetType{
	DiscountApplicationTargetTypeLineItem,
	DiscountApplicationTargetTypeShippingLine,
}

func (e DiscountApplicationTargetType) IsValid() bool {
	switch e {
	case DiscountApplicationTargetTypeLineItem, DiscountApplicationTargetTypeShippingLine:
		return true
	}
	return false
}

func (e DiscountApplicationTargetType) String() string {
	return string(e)
}

func (e *DiscountApplicationTargetType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscountApplicationTargetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscountApplicationTargetType", str)
	}
	return nil
}

func (e DiscountApplicationTargetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// List of supported image content types.
type ImageContentType string

const (
	// A PNG image.
	ImageContentTypePng ImageContentType = "PNG"
	// A JPG image.
	ImageContentTypeJpg ImageContentType = "JPG"
	// A WEBP image.
	ImageContentTypeWebp ImageContentType = "WEBP"
)

var AllImageContentType = []ImageContentType{
	ImageContentTypePng,
	ImageContentTypeJpg,
	ImageContentTypeWebp,
}

func (e ImageContentType) IsValid() bool {
	switch e {
	case ImageContentTypePng, ImageContentTypeJpg, ImageContentTypeWebp:
		return true
	}
	return false
}

func (e ImageContentType) String() string {
	return string(e)
}

func (e *ImageContentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageContentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageContentType", str)
	}
	return nil
}

func (e ImageContentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Metafield value types.
type MetafieldValueType string

const (
	// A string metafield.
	MetafieldValueTypeString MetafieldValueType = "STRING"
	// An integer metafield.
	MetafieldValueTypeInteger MetafieldValueType = "INTEGER"
	// A json string metafield.
	MetafieldValueTypeJSONString MetafieldValueType = "JSON_STRING"
)

var AllMetafieldValueType = []MetafieldValueType{
	MetafieldValueTypeString,
	MetafieldValueTypeInteger,
	MetafieldValueTypeJSONString,
}

func (e MetafieldValueType) IsValid() bool {
	switch e {
	case MetafieldValueTypeString, MetafieldValueTypeInteger, MetafieldValueTypeJSONString:
		return true
	}
	return false
}

func (e MetafieldValueType) String() string {
	return string(e)
}

func (e *MetafieldValueType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetafieldValueType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetafieldValueType", str)
	}
	return nil
}

func (e MetafieldValueType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the Order query.
type OrderSortKeys string

const (
	// Sort by the `processed_at` value.
	OrderSortKeysProcessedAt OrderSortKeys = "PROCESSED_AT"
	// Sort by the `total_price` value.
	OrderSortKeysTotalPrice OrderSortKeys = "TOTAL_PRICE"
	// Sort by the `id` value.
	OrderSortKeysID OrderSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	OrderSortKeysRelevance OrderSortKeys = "RELEVANCE"
)

var AllOrderSortKeys = []OrderSortKeys{
	OrderSortKeysProcessedAt,
	OrderSortKeysTotalPrice,
	OrderSortKeysID,
	OrderSortKeysRelevance,
}

func (e OrderSortKeys) IsValid() bool {
	switch e {
	case OrderSortKeysProcessedAt, OrderSortKeysTotalPrice, OrderSortKeysID, OrderSortKeysRelevance:
		return true
	}
	return false
}

func (e OrderSortKeys) String() string {
	return string(e)
}

func (e *OrderSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderSortKeys", str)
	}
	return nil
}

func (e OrderSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the Page query.
type PageSortKeys string

const (
	// Sort by the `title` value.
	PageSortKeysTitle PageSortKeys = "TITLE"
	// Sort by the `updated_at` value.
	PageSortKeysUpdatedAt PageSortKeys = "UPDATED_AT"
	// Sort by the `id` value.
	PageSortKeysID PageSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	PageSortKeysRelevance PageSortKeys = "RELEVANCE"
)

var AllPageSortKeys = []PageSortKeys{
	PageSortKeysTitle,
	PageSortKeysUpdatedAt,
	PageSortKeysID,
	PageSortKeysRelevance,
}

func (e PageSortKeys) IsValid() bool {
	switch e {
	case PageSortKeysTitle, PageSortKeysUpdatedAt, PageSortKeysID, PageSortKeysRelevance:
		return true
	}
	return false
}

func (e PageSortKeys) String() string {
	return string(e)
}

func (e *PageSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PageSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PageSortKeys", str)
	}
	return nil
}

func (e PageSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the ProductCollection query.
type ProductCollectionSortKeys string

const (
	// Sort by the `title` value.
	ProductCollectionSortKeysTitle ProductCollectionSortKeys = "TITLE"
	// Sort by the `price` value.
	ProductCollectionSortKeysPrice ProductCollectionSortKeys = "PRICE"
	// Sort by the `best-selling` value.
	ProductCollectionSortKeysBestSelling ProductCollectionSortKeys = "BEST_SELLING"
	// Sort by the `created` value.
	ProductCollectionSortKeysCreated ProductCollectionSortKeys = "CREATED"
	// Sort by the `id` value.
	ProductCollectionSortKeysID ProductCollectionSortKeys = "ID"
	// Sort by the `manual` value.
	ProductCollectionSortKeysManual ProductCollectionSortKeys = "MANUAL"
	// Sort by the `collection-default` value.
	ProductCollectionSortKeysCollectionDefault ProductCollectionSortKeys = "COLLECTION_DEFAULT"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	ProductCollectionSortKeysRelevance ProductCollectionSortKeys = "RELEVANCE"
)

var AllProductCollectionSortKeys = []ProductCollectionSortKeys{
	ProductCollectionSortKeysTitle,
	ProductCollectionSortKeysPrice,
	ProductCollectionSortKeysBestSelling,
	ProductCollectionSortKeysCreated,
	ProductCollectionSortKeysID,
	ProductCollectionSortKeysManual,
	ProductCollectionSortKeysCollectionDefault,
	ProductCollectionSortKeysRelevance,
}

func (e ProductCollectionSortKeys) IsValid() bool {
	switch e {
	case ProductCollectionSortKeysTitle, ProductCollectionSortKeysPrice, ProductCollectionSortKeysBestSelling, ProductCollectionSortKeysCreated, ProductCollectionSortKeysID, ProductCollectionSortKeysManual, ProductCollectionSortKeysCollectionDefault, ProductCollectionSortKeysRelevance:
		return true
	}
	return false
}

func (e ProductCollectionSortKeys) String() string {
	return string(e)
}

func (e *ProductCollectionSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductCollectionSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductCollectionSortKeys", str)
	}
	return nil
}

func (e ProductCollectionSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the ProductImage query.
type ProductImageSortKeys string

const (
	// Sort by the `created_at` value.
	ProductImageSortKeysCreatedAt ProductImageSortKeys = "CREATED_AT"
	// Sort by the `position` value.
	ProductImageSortKeysPosition ProductImageSortKeys = "POSITION"
	// Sort by the `id` value.
	ProductImageSortKeysID ProductImageSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	ProductImageSortKeysRelevance ProductImageSortKeys = "RELEVANCE"
)

var AllProductImageSortKeys = []ProductImageSortKeys{
	ProductImageSortKeysCreatedAt,
	ProductImageSortKeysPosition,
	ProductImageSortKeysID,
	ProductImageSortKeysRelevance,
}

func (e ProductImageSortKeys) IsValid() bool {
	switch e {
	case ProductImageSortKeysCreatedAt, ProductImageSortKeysPosition, ProductImageSortKeysID, ProductImageSortKeysRelevance:
		return true
	}
	return false
}

func (e ProductImageSortKeys) String() string {
	return string(e)
}

func (e *ProductImageSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductImageSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductImageSortKeys", str)
	}
	return nil
}

func (e ProductImageSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the Product query.
type ProductSortKeys string

const (
	// Sort by the `title` value.
	ProductSortKeysTitle ProductSortKeys = "TITLE"
	// Sort by the `product_type` value.
	ProductSortKeysProductType ProductSortKeys = "PRODUCT_TYPE"
	// Sort by the `vendor` value.
	ProductSortKeysVendor ProductSortKeys = "VENDOR"
	// Sort by the `updated_at` value.
	ProductSortKeysUpdatedAt ProductSortKeys = "UPDATED_AT"
	// Sort by the `created_at` value.
	ProductSortKeysCreatedAt ProductSortKeys = "CREATED_AT"
	// Sort by the `best_selling` value.
	ProductSortKeysBestSelling ProductSortKeys = "BEST_SELLING"
	// Sort by the `price` value.
	ProductSortKeysPrice ProductSortKeys = "PRICE"
	// Sort by the `id` value.
	ProductSortKeysID ProductSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	ProductSortKeysRelevance ProductSortKeys = "RELEVANCE"
)

var AllProductSortKeys = []ProductSortKeys{
	ProductSortKeysTitle,
	ProductSortKeysProductType,
	ProductSortKeysVendor,
	ProductSortKeysUpdatedAt,
	ProductSortKeysCreatedAt,
	ProductSortKeysBestSelling,
	ProductSortKeysPrice,
	ProductSortKeysID,
	ProductSortKeysRelevance,
}

func (e ProductSortKeys) IsValid() bool {
	switch e {
	case ProductSortKeysTitle, ProductSortKeysProductType, ProductSortKeysVendor, ProductSortKeysUpdatedAt, ProductSortKeysCreatedAt, ProductSortKeysBestSelling, ProductSortKeysPrice, ProductSortKeysID, ProductSortKeysRelevance:
		return true
	}
	return false
}

func (e ProductSortKeys) String() string {
	return string(e)
}

func (e *ProductSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductSortKeys", str)
	}
	return nil
}

func (e ProductSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the ProductVariant query.
type ProductVariantSortKeys string

const (
	// Sort by the `title` value.
	ProductVariantSortKeysTitle ProductVariantSortKeys = "TITLE"
	// Sort by the `sku` value.
	ProductVariantSortKeysSku ProductVariantSortKeys = "SKU"
	// Sort by the `position` value.
	ProductVariantSortKeysPosition ProductVariantSortKeys = "POSITION"
	// Sort by the `id` value.
	ProductVariantSortKeysID ProductVariantSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	ProductVariantSortKeysRelevance ProductVariantSortKeys = "RELEVANCE"
)

var AllProductVariantSortKeys = []ProductVariantSortKeys{
	ProductVariantSortKeysTitle,
	ProductVariantSortKeysSku,
	ProductVariantSortKeysPosition,
	ProductVariantSortKeysID,
	ProductVariantSortKeysRelevance,
}

func (e ProductVariantSortKeys) IsValid() bool {
	switch e {
	case ProductVariantSortKeysTitle, ProductVariantSortKeysSku, ProductVariantSortKeysPosition, ProductVariantSortKeysID, ProductVariantSortKeysRelevance:
		return true
	}
	return false
}

func (e ProductVariantSortKeys) String() string {
	return string(e)
}

func (e *ProductVariantSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductVariantSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductVariantSortKeys", str)
	}
	return nil
}

func (e ProductVariantSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TransactionKind string

const (
	TransactionKindSale             TransactionKind = "SALE"
	TransactionKindCapture          TransactionKind = "CAPTURE"
	TransactionKindAuthorization    TransactionKind = "AUTHORIZATION"
	TransactionKindEmvAuthorization TransactionKind = "EMV_AUTHORIZATION"
	TransactionKindChange           TransactionKind = "CHANGE"
)

var AllTransactionKind = []TransactionKind{
	TransactionKindSale,
	TransactionKindCapture,
	TransactionKindAuthorization,
	TransactionKindEmvAuthorization,
	TransactionKindChange,
}

func (e TransactionKind) IsValid() bool {
	switch e {
	case TransactionKindSale, TransactionKindCapture, TransactionKindAuthorization, TransactionKindEmvAuthorization, TransactionKindChange:
		return true
	}
	return false
}

func (e TransactionKind) String() string {
	return string(e)
}

func (e *TransactionKind) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransactionKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransactionKind", str)
	}
	return nil
}

func (e TransactionKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TransactionStatus string

const (
	TransactionStatusPending TransactionStatus = "PENDING"
	TransactionStatusSuccess TransactionStatus = "SUCCESS"
	TransactionStatusFailure TransactionStatus = "FAILURE"
	TransactionStatusError   TransactionStatus = "ERROR"
)

var AllTransactionStatus = []TransactionStatus{
	TransactionStatusPending,
	TransactionStatusSuccess,
	TransactionStatusFailure,
	TransactionStatusError,
}

func (e TransactionStatus) IsValid() bool {
	switch e {
	case TransactionStatusPending, TransactionStatusSuccess, TransactionStatusFailure, TransactionStatusError:
		return true
	}
	return false
}

func (e TransactionStatus) String() string {
	return string(e)
}

func (e *TransactionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransactionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransactionStatus", str)
	}
	return nil
}

func (e TransactionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Units of measurement for weight.
type WeightUnit string

const (
	// 1 kilogram equals 1000 grams.
	WeightUnitKilograms WeightUnit = "KILOGRAMS"
	// Metric system unit of mass.
	WeightUnitGrams WeightUnit = "GRAMS"
	// 1 pound equals 16 ounces.
	WeightUnitPounds WeightUnit = "POUNDS"
	// Imperial system unit of mass.
	WeightUnitOunces WeightUnit = "OUNCES"
)

var AllWeightUnit = []WeightUnit{
	WeightUnitKilograms,
	WeightUnitGrams,
	WeightUnitPounds,
	WeightUnitOunces,
}

func (e WeightUnit) IsValid() bool {
	switch e {
	case WeightUnitKilograms, WeightUnitGrams, WeightUnitPounds, WeightUnitOunces:
		return true
	}
	return false
}

func (e WeightUnit) String() string {
	return string(e)
}

func (e *WeightUnit) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WeightUnit(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WeightUnit", str)
	}
	return nil
}

func (e WeightUnit) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
